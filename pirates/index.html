<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pirate Game – Quest System with Command Keys</title>
  <style>
    /* Page & Canvas styling */
    body {
      margin: 0;
      background: #87CEEB;
      font-family: sans-serif;
      overflow: hidden;
    }
    #gameCanvas {
      border: 2px solid black;
      background: #87CEEB;
      display: block;
    }
    /* Minimap container in upper-right */
    #minimapContainer {
      position: absolute;
      top: 10px;
      right: 10px;
      border: 1px solid #000;
      background: rgba(255,255,255,0.7);
      width: 200px;
      height: 200px;
    }
    /* HUD (player info) in top-left */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px;
      font-size: 14px;
    }
    /* Quest log panel positioned below the minimap */
    #questLog {
      position: absolute;
      top: 220px; /* 10px (minimap top) + 200px (minimap height) + 10px margin */
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px;
      font-size: 14px;
      max-height: 200px;
      overflow-y: auto;
      width: 200px;
    }
    /* Command keys panel positioned below the quest log */
    #commandKeys {
      position: absolute;
      top: 430px; /* questLog top (220) + questLog height (200) + 10px margin */
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px;
      font-size: 14px;
      max-height: 150px;
      overflow-y: auto;
      width: 200px;
    }
    /* Log console at bottom */
    #log {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      background: rgba(0,0,0,0.8);
      color: #0f0;
      font-family: monospace;
      overflow-y: auto;
      padding: 5px;
      box-sizing: border-box;
    }
    /* Trade menu overlay (hidden by default) */
    #tradeMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: #fff;
      padding: 20px;
      border: 2px solid #fff;
      display: none;
      z-index: 100;
    }
    /* Governor and upgrade overlays */
    #governorMenu,
    #upgradeMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: #fff;
      padding: 20px;
      border: 2px solid #fff;
      display: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <!-- Main game canvas (800×600) -->
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <!-- Minimap container -->
  <div id="minimapContainer">
    <canvas id="minimap" width="200" height="200"></canvas>
  </div>
  <!-- HUD (player info) -->
  <div id="hud"></div>
  <!-- Quest Log (active quests, below minimap) -->
  <div id="questLog"></div>
  <!-- Command Keys panel (below quest log) -->
  <div id="commandKeys">
    <strong>Command Keys:</strong><br>
    &uarr; : Move forward<br>
    &larr; / &rarr; : Rotate ship<br>
    Space: Fire cannon<br>
    P: Pause/Unpause<br>
    M: Toggle minimap<br>
    T: Trade (if near a city)<br>
    B: Board enemy ship<br>
    C: Capture enemy ship<br>
    S: Save game<br>
    L: Load game
  </div>
  <!-- Log console -->
  <div id="log"></div>
  <!-- Trade Menu (shown when trading) -->
  <div id="tradeMenu"></div>
  <!-- Governor and Upgrade Menus -->
  <div id="governorMenu"></div>
  <div id="upgradeMenu"></div>
  
  <script>
    /***********************
     * Global Game Settings
     ***********************/
    const worldWidth = 2400, worldHeight = 1600;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const hudDiv = document.getElementById('hud');
    const questLogDiv = document.getElementById('questLog');
    const logDiv = document.getElementById('log');
    const tradeMenuDiv = document.getElementById('tradeMenu');
    const governorMenuDiv = document.getElementById('governorMenu');
    const upgradeMenuDiv = document.getElementById('upgradeMenu');
    
    let lastTime = 0;
    let isPaused = false;
    let inTradeMode = false;
    let showMinimap = true;

    // Global wind state (direction radians, speed pixels per update)
    let windDirection = 0;
    let windSpeed = 0.5;

    function updateWind() {
      windDirection = normalizeAngle(
        windDirection + (Math.random() - 0.5) * 0.2
      );
      windSpeed = 0.3 + Math.random() * 0.7;
    }
    updateWind();
    setInterval(updateWind, 15000);

    // Arrays to hold game objects.
    let islands = [];
    let cities = [];
    let ships = [];
    let cannonballs = [];
    let boardCandidate = null;
    let quests = []; // Global quest log.

    // Navigation grid for AI pathfinding
    const gridSize = 80;
    const gridCols = Math.floor(worldWidth / gridSize);
    const gridRows = Math.floor(worldHeight / gridSize);
    let navGrid = [];

    function buildNavGrid() {
      navGrid = [];
      for (let r = 0; r < gridRows; r++) {
        const row = [];
        for (let c = 0; c < gridCols; c++) {
          const x = c * gridSize + gridSize / 2;
          const y = r * gridSize + gridSize / 2;
          let blocked = false;
          for (let island of islands) {
            if (pointInPolygon(x, y, island.vertices)) { blocked = true; break; }
          }
          row.push(blocked ? 1 : 0);
        }
        navGrid.push(row);
      }
      logMessage('Navigation grid generated.');
    }

    function findPath(sx, sy, gx, gy) {
      const start = { c: Math.floor(sx / gridSize), r: Math.floor(sy / gridSize) };
      const goal  = { c: Math.floor(gx / gridSize), r: Math.floor(gy / gridSize) };

      const key = p => p.r + ',' + p.c;
      let open = [start];
      const came = {};
      const gScore = { [key(start)]: 0 };
      const fScore = { [key(start)]: distance(start.c, start.r, goal.c, goal.r) };

      while (open.length) {
        let idx = 0;
        for (let i = 1; i < open.length; i++) {
          if (fScore[key(open[i])] < fScore[key(open[idx])]) idx = i;
        }
        const current = open.splice(idx, 1)[0];
        if (current.c === goal.c && current.r === goal.r) {
          const path = [];
          let curKey = key(current);
          while (came[curKey]) {
            const [r, c] = curKey.split(',').map(Number);
            path.push({ x: c * gridSize + gridSize / 2, y: r * gridSize + gridSize / 2 });
            curKey = came[curKey];
          }
          path.reverse();
          return path;
        }
        const neighbors = [
          { r: current.r - 1, c: current.c },
          { r: current.r + 1, c: current.c },
          { r: current.r, c: current.c - 1 },
          { r: current.r, c: current.c + 1 },
        ];
        for (let n of neighbors) {
          if (n.r < 0 || n.r >= gridRows || n.c < 0 || n.c >= gridCols) continue;
          if (navGrid[n.r][n.c] === 1) continue;
          const nk = key(n);
          const tentativeG = gScore[key(current)] + 1;
          if (tentativeG < (gScore[nk] ?? Infinity)) {
            came[nk] = key(current);
            gScore[nk] = tentativeG;
            fScore[nk] = tentativeG + distance(n.c, n.r, goal.c, goal.r);
            if (!open.some(o => o.r === n.r && o.c === n.c)) open.push(n);
          }
        }
      }
      return [];
    }
    
    // Key tracking.
    const keys = {};
    
    // Define nations and their Unicode flags.
    const nations = {
      "Netherlands": "🇳🇱",
      "Spain":      "🇪🇸",
      "France":     "🇫🇷",
      "England":    "🇬🇧"
    };
    
    // Relationships between nations.
      let relationships = {};
      let playerReputation = {};
      let lettersOfMarque = {};
      let storyMilestones = {};
    function initRelationships() {
      const nationKeys = Object.keys(nations);
      for (let i = 0; i < nationKeys.length; i++) {
        for (let j = i + 1; j < nationKeys.length; j++) {
          const key = nationKeys[i] + '-' + nationKeys[j];
          relationships[key] = Math.random() < 0.5 ? 'peace' : 'war';
        }
      }
      logMessage("Initial relationships set.");
    }
    setInterval(() => {
      const nationKeys = Object.keys(nations);
      for (let i = 0; i < nationKeys.length; i++) {
        for (let j = i + 1; j < nationKeys.length; j++) {
          const key = nationKeys[i] + '-' + nationKeys[j];
          relationships[key] = Math.random() < 0.5 ? 'peace' : 'war';
          logMessage(`Relationship between ${nationKeys[i]} and ${nationKeys[j]} is now ${relationships[key]}.`);
        }
      }
    }, 120000);

    function initReputation() {
      Object.keys(nations).forEach(n => {
        playerReputation[n] = 0;
        lettersOfMarque[n] = false;
      });
    }
    
    function areAtWar(nationA, nationB) {
      if (nationA === nationB) return false;
      const sorted = [nationA, nationB].sort();
      return relationships[sorted[0] + '-' + sorted[1]] === 'war';
    }
    
    /***********************
     * Utility Functions
     ***********************/
    function logMessage(message) {
      const p = document.createElement('p');
      p.textContent = message;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }
    
    // Ray-casting algorithm for point-in-polygon.
    function pointInPolygon(x, y, vertices) {
      let inside = false;
      for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x, yi = vertices[i].y;
        const xj = vertices[j].x, yj = vertices[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    
    function normalizeAngle(angle) {
      while (angle > Math.PI) angle -= 2 * Math.PI;
      while (angle < -Math.PI) angle += 2 * Math.PI;
      return angle;
    }
    
    function randomPrice(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    /***********************
     * Quest System
     ***********************/
      class Quest {
        constructor(id, type, data) {
          this.id = id;
          this.type = type;
          Object.assign(this, data);
          this.status = "active"; // active, completed, or failed.

          switch (type) {
            case "delivery":
              this.description = `Deliver ${this.amount} ${this.good} from ${this.originCity.name} to ${this.targetCity.name} for ${this.reward} gold.`;
              break;
            case "treasure":
              this.description = `Find hidden treasure near ${this.targetCity.name} for ${this.reward} gold.`;
              break;
            case "rescue":
              this.rescued = false;
              this.description = `Rescue the captive at ${this.targetCity.name} and return to ${this.originCity.name} for ${this.reward} gold.`;
              break;
            case "bounty":
              this.enemyDefeated = false;
              this.description = `Hunt down the pirate ${this.enemy} near ${this.targetCity.name} for ${this.reward} gold.`;
              break;
          }
        }
      }

      // Individual quest generators.
      function generateDeliveryQuest() {
        if (cities.length < 2) return null;
        let origin = cities[Math.floor(Math.random() * cities.length)];
        let target;
        do {
          target = cities[Math.floor(Math.random() * cities.length)];
        } while (target.id === origin.id);
        const goods = ["Rum", "Spices", "Gold"];
        const good = goods[Math.floor(Math.random() * goods.length)];
        const amount = Math.floor(Math.random() * 3) + 1;
        const reward = Math.floor(Math.random() * 100) + 50;
        return new Quest(Date.now(), "delivery", { originCity: origin, targetCity: target, good, amount, reward });
      }

      function generateTreasureHuntQuest() {
        if (cities.length === 0) return null;
        const target = cities[Math.floor(Math.random() * cities.length)];
        const reward = Math.floor(Math.random() * 200) + 100;
        return new Quest(Date.now(), "treasure", { targetCity: target, reward });
      }

      function generateRescueQuest() {
        if (cities.length < 2) return null;
        let origin = cities[Math.floor(Math.random() * cities.length)];
        let target;
        do {
          target = cities[Math.floor(Math.random() * cities.length)];
        } while (target.id === origin.id);
        const reward = Math.floor(Math.random() * 150) + 75;
        return new Quest(Date.now(), "rescue", { originCity: origin, targetCity: target, reward });
      }

      function generateBountyHuntQuest() {
        if (cities.length === 0) return null;
        const target = cities[Math.floor(Math.random() * cities.length)];
        const reward = Math.floor(Math.random() * 200) + 100;
        const enemy = "Notorious Pirate";
        return new Quest(Date.now(), "bounty", { targetCity: target, reward, enemy });
      }

      // Generate a random quest.
      function generateRandomQuest() {
        const generators = [generateDeliveryQuest, generateTreasureHuntQuest, generateRescueQuest, generateBountyHuntQuest];
        const generator = generators[Math.floor(Math.random() * generators.length)];
        const quest = generator();
        if (quest) {
          quests.push(quest);
          logMessage("New quest added: " + quest.description);
          updateQuestLogUI();
        }
      }

      function unlockStoryMissions() {
        const totalRep = Object.values(playerReputation).reduce((a, b) => a + b, 0);
        if (totalRep >= 20 && !storyMilestones.firstStory) {
          const target = cities[Math.floor(Math.random() * cities.length)];
          const quest = new Quest(Date.now(), "treasure", { targetCity: target, reward: 500 });
          quest.isStory = true;
          quests.push(quest);
          storyMilestones.firstStory = true;
          logMessage("Story mission unlocked: " + quest.description);
          updateQuestLogUI();
        }
      }
    
      // Check for quest completions.
      function checkQuestCompletions() {
        for (let i = quests.length - 1; i >= 0; i--) {
          let quest = quests[i];
          if (quest.status !== "active") continue;

          if (quest.type === "delivery") {
            if (distance(playerShip.x, playerShip.y, quest.targetCity.x, quest.targetCity.y) < 100) {
              if ((playerShip.inventory[quest.good] || 0) >= quest.amount) {
                playerShip.inventory[quest.good] -= quest.amount;
                playerShip.money += quest.reward;
                playerReputation[quest.originCity.nation]++;
                quest.status = "completed";
                logMessage("Quest completed: " + quest.description);
                quests.splice(i, 1);
                updateQuestLogUI();
                unlockStoryMissions();
              }
            }
          } else if (quest.type === "treasure") {
            if (distance(playerShip.x, playerShip.y, quest.targetCity.x, quest.targetCity.y) < 100) {
              playerShip.money += quest.reward;
              playerReputation[quest.targetCity.nation]++;
              quest.status = "completed";
              logMessage("Quest completed: " + quest.description);
              quests.splice(i, 1);
              updateQuestLogUI();
              unlockStoryMissions();
            }
          } else if (quest.type === "rescue") {
            if (!quest.rescued && distance(playerShip.x, playerShip.y, quest.targetCity.x, quest.targetCity.y) < 100) {
              quest.rescued = true;
              quest.description = `Return the captive to ${quest.originCity.name}.`;
              logMessage("Captive rescued! Return to " + quest.originCity.name + ".");
              updateQuestLogUI();
            } else if (quest.rescued && distance(playerShip.x, playerShip.y, quest.originCity.x, quest.originCity.y) < 100) {
              playerShip.money += quest.reward;
              playerReputation[quest.originCity.nation] += 2;
              quest.status = "completed";
              logMessage("Quest completed: " + quest.description);
              quests.splice(i, 1);
              updateQuestLogUI();
              unlockStoryMissions();
            }
          } else if (quest.type === "bounty") {
            if (distance(playerShip.x, playerShip.y, quest.targetCity.x, quest.targetCity.y) < 100) {
              playerShip.money += quest.reward;
              playerReputation[quest.targetCity.nation] += 2;
              quest.status = "completed";
              logMessage("Quest completed: " + quest.description);
              quests.splice(i, 1);
              updateQuestLogUI();
              unlockStoryMissions();
            }
          }
        }
      }
    
    // Update the quest log UI.
    function updateQuestLogUI() {
      if (quests.length === 0) {
        questLogDiv.innerHTML = "<strong>No active quests.</strong>";
      } else {
        let html = "<strong>Active Quests:</strong><br>";
        quests.forEach(q => {
          html += `<p>${q.description}</p>`;
        });
        questLogDiv.innerHTML = html;
      }
    }
    
    // Generate a new quest every 60 seconds.
    setInterval(generateRandomQuest, 60000);
    
    /***********************
     * Object Classes (Game Objects)
     ***********************/
    class Island {
      constructor(vertices) {
        this.vertices = vertices;
        this.city = null;
      }
      draw(ctx, offsetX, offsetY) {
        ctx.fillStyle = "#228B22";
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x - offsetX, this.vertices[0].y - offsetY);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.vertices[i].x - offsetX, this.vertices[i].y - offsetY);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#006400";
        ctx.stroke();
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = "#228B22";
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x * scale, this.vertices[0].y * scale);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.vertices[i].x * scale, this.vertices[i].y * scale);
        }
        ctx.closePath();
        ctx.fill();
      }
    }
    
    class City {
      constructor(id, name, x, y, nation) {
        this.id = id;
        this.name = name;
        this.x = x;
        this.y = y;
        this.nation = nation;
        this.population = 1000;

        // Each good now tracks its economic behaviour.  Prices are seeded
        // randomly but we also keep a basePrice to anchor future
        // fluctuations.  productionRate/consumptionRate are measured per
        // second and tradeVolume captures player trading since the last
        // economy update.
        const rumBase = randomPrice(10, 20);
        const spiceBase = randomPrice(15, 30);
        const goldBase = randomPrice(50, 100);
        this.goods = {
          "Rum": {
            price: rumBase,
            basePrice: rumBase,
            quantity: 100,
            productionRate: 2,
            consumptionRate: 1,
            maxStorage: 200,
            tradeVolume: 0
          },
          "Spices": {
            price: spiceBase,
            basePrice: spiceBase,
            quantity: 100,
            productionRate: 1.5,
            consumptionRate: 1,
            maxStorage: 200,
            tradeVolume: 0
          },
          "Gold": {
            price: goldBase,
            basePrice: goldBase,
            quantity: 50,
            productionRate: 0.5,
            consumptionRate: 0.2,
            maxStorage: 100,
            tradeVolume: 0
          }
        };
      }
      draw(ctx, offsetX, offsetY) {
        ctx.font = "16px sans-serif";
        ctx.fillText("🏠", this.x - offsetX - 8, this.y - offsetY + 8);
        // Draw the city name below the symbol using 12px font.
        ctx.font = "12px sans-serif";
        ctx.fillText(this.name, this.x - offsetX - 8, this.y - offsetY + 22);
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = "black";
        ctx.fillText("🏠", this.x * scale - 6, this.y * scale + 6);
        ctx.fillText(nations[this.nation], this.x * scale + 6, this.y * scale - 6);
      }
    }
    
    class Ship {
      constructor(id, type, nation, x, y, isPlayer = false) {
        this.id = id;
        this.type = type;
        this.nation = nation;
        this.x = x;
        this.y = y;
        this.angle = Math.random() * 2 * Math.PI;
        this.speed = 0;
        this.maxSpeed = type === "Sloop" ? 2 : type === "Brig" ? 1.5 : 1;
        this.hull = type === "Sloop" ? 100 : type === "Brig" ? 150 : 200;
        this.maxHull = this.hull;
        this.sail = 100;
        this.maxSail = 100;
        this.inventory = { "Rum": 0, "Spices": 0, "Gold": 0 };
        this.cannons = type === "Sloop" ? 2 : type === "Brig" ? 4 : 8;
        this.ammo = this.cannons * 10;
        this.maxAmmo = this.ammo;
        this.crew = type === "Sloop" ? 10 : type === "Brig" ? 20 : 30;
        this.maxCrew = this.crew;
        this.isPlayer = isPlayer;
        this.targetCity = null;
        this.homeCity = null;
        this.fireCooldown = 0;
        this.captured = false;
        this.money = 0;
        this.specialists = [];
        this.path = [];
        this.pathIndex = 0;
        this.behavior = 'trade';
        this.tradeRoute = [];
        this.routeIndex = 0;
        this.patrolPoints = [];
        this.patrolIndex = 0;
        this.chasing = null;
      }
      setCourse(destX, destY) {
        this.path = findPath(this.x, this.y, destX, destY);
        this.pathIndex = 0;
        if (this.path.length === 0) {
          logMessage(`${this.nation} ship failed to plot course.`);
        } else {
          logMessage(`${this.nation} ship plotting course with ${this.path.length} waypoints.`);
        }
      }
      update(dt) {
        const windX = Math.cos(windDirection) * windSpeed;
        const windY = Math.sin(windDirection) * windSpeed;
        const relWind = normalizeAngle(windDirection - this.angle);
        const typeTurn =
          this.type === "Sloop" ? 0.07 : this.type === "Brig" ? 0.05 : 0.03;
        const windTurnFactor = 1 + Math.sin(relWind) * 0.3;
        const sailEfficiency =
          this.type === "Sloop" ? 1 : this.type === "Brig" ? 0.8 : 0.6;
        const baseSpeed = this.maxSpeed * sailEfficiency * (this.sail / this.maxSail);
        const windMod = Math.cos(relWind) * windSpeed;

        if (this.isPlayer) {
          if (keys["ArrowLeft"]) this.angle -= typeTurn * windTurnFactor;
          if (keys["ArrowRight"]) this.angle += typeTurn * windTurnFactor;
          this.speed = keys["ArrowUp"] ? Math.max(0, baseSpeed + windMod) : 0;
        } else {
          if (this.chasing && distance(this.chasing.x, this.chasing.y, this.x, this.y) > 400) {
            logMessage(`${this.nation} patrol ship lost target.`);
            this.chasing = null;
          }
          if (this.path.length === 0) {
            if (this.chasing) {
              this.setCourse(this.chasing.x, this.chasing.y);
            } else if (this.behavior === 'trade' && this.targetCity) {
              this.setCourse(this.targetCity.x, this.targetCity.y);
            } else if (this.behavior === 'patrol' && this.patrolPoints.length) {
              const pt = this.patrolPoints[this.patrolIndex];
              this.setCourse(pt.x, pt.y);
            }
          }
          if (this.path.length) {
            const waypoint = this.path[this.pathIndex];
            let desired = {
              x: waypoint.x - this.x - windX * 20,
              y: waypoint.y - this.y - windY * 20,
            };
            let mag = Math.hypot(desired.x, desired.y);
            if (mag > 0) { desired.x /= mag; desired.y /= mag; }
            let repulsion = { x: 0, y: 0 };
            for (let island of islands) {
              let center = { x: 0, y: 0 };
              for (let vertex of island.vertices) { center.x += vertex.x; center.y += vertex.y; }
              center.x /= island.vertices.length;
              center.y /= island.vertices.length;
              let avgRadius = 0;
              for (let vertex of island.vertices) {
                avgRadius += distance(center.x, center.y, vertex.x, vertex.y);
              }
              avgRadius /= island.vertices.length;
              let buffer = 50;
              let d = distance(this.x, this.y, center.x, center.y);
              if (d < avgRadius + buffer) {
                let factor = (avgRadius + buffer - d) / (avgRadius + buffer);
                let away = { x: this.x - center.x, y: this.y - center.y };
                let awayMag = Math.hypot(away.x, away.y);
                if (awayMag > 0) { away.x /= awayMag; away.y /= awayMag; }
                repulsion.x += away.x * factor;
                repulsion.y += away.y * factor;
              }
            }
            let steering = {
              x: desired.x + repulsion.x * 2,
              y: desired.y + repulsion.y * 2,
            };
            let steerMag = Math.hypot(steering.x, steering.y);
            if (steerMag > 0) { steering.x /= steerMag; steering.y /= steerMag; }
            let targetAngle = Math.atan2(steering.y, steering.x);
            let angleDiff = normalizeAngle(targetAngle - this.angle);
            let turnRate = typeTurn * windTurnFactor;
            if (angleDiff > turnRate) this.angle += turnRate;
            else if (angleDiff < -turnRate) this.angle -= turnRate;
            else this.angle = targetAngle;
            this.speed = Math.max(0, baseSpeed * 0.8 + windMod);
            if (distance(this.x, this.y, waypoint.x, waypoint.y) < gridSize / 2) {
              this.pathIndex++;
              if (this.pathIndex >= this.path.length) {
                this.path = [];
              }
            }
          } else {
            this.speed = Math.max(0, baseSpeed * 0.5 + windMod);
          }
        }
        const newX =
          this.x + Math.cos(this.angle) * this.speed + windX;
        const newY =
          this.y + Math.sin(this.angle) * this.speed + windY;
        let collision = false;
        for (let island of islands) {
          if (pointInPolygon(newX, newY, island.vertices)) { collision = true; break; }
        }
        if (!collision) { this.x = newX; this.y = newY; }
        if (this.fireCooldown > 0) this.fireCooldown -= dt;
        if (!this.isPlayer && !inTradeMode && this.fireCooldown <= 0 && playerShip) {
          const d = distance(this.x, this.y, playerShip.x, playerShip.y);
          if (d < 300 && areAtWar(this.nation, playerShip.nation)) {
            fireCannon(this, playerShip.x, playerShip.y);
            this.fireCooldown = 2;
          }
        }
        if (!this.isPlayer) {
          for (let island of islands) {
            if (pointInPolygon(this.x, this.y, island.vertices)) { repositionEnemyShip(this, island); break; }
          }
          if (this.behavior === 'trade' && this.targetCity &&
              distance(this.x, this.y, this.targetCity.x, this.targetCity.y) < 100) {
            this.routeIndex = (this.routeIndex + 1) % this.tradeRoute.length;
            this.targetCity = this.tradeRoute[this.routeIndex];
            logMessage(`${this.nation} ship now trading to ${this.targetCity.name}.`);
            this.setCourse(this.targetCity.x, this.targetCity.y);
          }
          if (this.behavior === 'patrol' && this.patrolPoints.length) {
            if (distance(this.x, this.y, this.patrolPoints[this.patrolIndex].x, this.patrolPoints[this.patrolIndex].y) < 50) {
              this.patrolIndex = (this.patrolIndex + 1) % this.patrolPoints.length;
              const pt = this.patrolPoints[this.patrolIndex];
              logMessage(`${this.nation} patrol ship moving to waypoint ${this.patrolIndex}.`);
              this.setCourse(pt.x, pt.y);
            }
            if (!this.chasing) {
              for (let s of ships) {
                if (s !== this && s.nation !== this.nation && areAtWar(s.nation, this.nation) && distance(this.x, this.y, s.x, s.y) < 300) {
                  this.chasing = s;
                  logMessage(`${this.nation} patrol ship engaging ${s.nation} vessel.`);
                  this.path = [];
                  break;
                }
              }
            } else {
              if (distance(this.x, this.y, this.chasing.x, this.chasing.y) < 50) {
                this.chasing = null;
              }
            }
          }
        }
        checkQuestCompletions();
      }
      draw(ctx, offsetX, offsetY) {
        ctx.save();
        ctx.translate(this.x - offsetX, this.y - offsetY);
        ctx.rotate(this.angle);
        ctx.font = "20px serif";
        ctx.fillText("⛵", -10, 10);
        if (this.isPlayer) {
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(30, 0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(30, 0);
          ctx.lineTo(25, -5);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(30, 0);
          ctx.lineTo(25, 5);
          ctx.stroke();
        }
        ctx.restore();
        ctx.font = "12px sans-serif";
        ctx.fillText(nations[this.nation], this.x - offsetX + 15, this.y - offsetY - 15);
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = this.isPlayer ? "blue" : "red";
        ctx.beginPath();
        ctx.arc(this.x * scale, this.y * scale, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
    
    class Cannonball {
      constructor(x, y, angle, owner) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 5;
        this.damage = 20;
        this.range = 300;
        this.distanceTraveled = 0;
        this.owner = owner;
      }
      update(dt) {
        const dx = Math.cos(this.angle) * this.speed;
        const dy = Math.sin(this.angle) * this.speed;
        this.x += dx;
        this.y += dy;
        this.distanceTraveled += Math.hypot(dx, dy);
      }
      draw(ctx, offsetX, offsetY) {
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(this.x - offsetX, this.y - offsetY, 5, 0, 2 * Math.PI);
        ctx.fill();
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(this.x * scale, this.y * scale, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
    
    function fireCannon(ship, targetX, targetY) {
      if (ship.ammo <= 0) {
        logMessage((ship.isPlayer ? "Player" : ship.nation + " ship") + " is out of ammo!");
        return;
      }
      ship.ammo--;
      const angle = Math.atan2(targetY - ship.y, targetX - ship.x);
      const cannonball = new Cannonball(
        ship.x + Math.cos(angle) * 20,
        ship.y + Math.sin(angle) * 20,
        angle,
        ship
      );
      cannonball.damageType = Math.random() < 0.5 ? "hull" : "sail";
      cannonballs.push(cannonball);
      logMessage((ship.isPlayer ? "Player" : ship.nation + " ship") +
        ` fired a cannonball. Ammo: ${ship.ammo}`);
    }
    
    function repositionEnemyShip(ship, island) {
      let repositioned = false;
      for (let i = 0; i < 10; i++) {
        const angle = Math.random() * 2 * Math.PI;
        const offsetDistance = Math.random() * 50 + 150;
        const newX = island.city.x + Math.cos(angle) * offsetDistance;
        const newY = island.city.y + Math.sin(angle) * offsetDistance;
        let safe = true;
        for (let otherIsland of islands) {
          if (pointInPolygon(newX, newY, otherIsland.vertices)) { safe = false; break; }
        }
        if (safe) {
          ship.x = newX;
          ship.y = newY;
          repositioned = true;
          logMessage(`${ship.nation} ship repositioned far away into the water near ${island.city.name}.`);
          break;
        }
      }
      if (!repositioned) {
        ship.x = island.city.x + 200;
        ship.y = island.city.y + 200;
        logMessage(`${ship.nation} ship repositioned (fallback) far away near ${island.city.name}.`);
      }
    }
    
    /***********************
     * World Generation
     ***********************/
    function generateIslands() {
      islands = [];
      for (let i = 0; i < 20; i++) {
        const cx = Math.random() * (worldWidth - 200) + 100;
        const cy = Math.random() * (worldHeight - 200) + 100;
        const numPoints = Math.floor(Math.random() * 5) + 5;
        const vertices = [];
        for (let j = 0; j < numPoints; j++) {
          const angle = (j / numPoints) * 2 * Math.PI;
          const radius = Math.random() * 50 + 30;
          const x = cx + Math.cos(angle) * radius + (Math.random() - 0.5) * 20;
          const y = cy + Math.sin(angle) * radius + (Math.random() - 0.5) * 20;
          vertices.push({ x, y });
        }
        islands.push(new Island(vertices));
      }
      buildNavGrid();
    }
    
    function generateCities() {
      cities = [];
      let cityId = 1;
      for (let island of islands) {
        const vertex = island.vertices[Math.floor(Math.random() * island.vertices.length)];
        const nationKeys = Object.keys(nations);
        const nation = nationKeys[Math.floor(Math.random() * nationKeys.length)];
        const city = new City(cityId, "City " + cityId, vertex.x, vertex.y, nation);
        cities.push(city);
        island.city = city;
        cityId++;
      }
    }
    
    function generateEnemyShips() {
      ships = ships.filter(s => s.isPlayer);
      let shipId = 1;
      for (let city of cities) {
        let spawnX = city.x + Math.random() * 100 - 50;
        let spawnY = city.y + Math.random() * 100 - 50;
        let onLand = false;
        for (let island of islands) {
          if (pointInPolygon(spawnX, spawnY, island.vertices)) { onLand = true; break; }
        }
        if (onLand) {
          spawnX = city.x + 100;
          spawnY = city.y + 100;
        }
        const types = ["Sloop", "Brig", "Galleon"];
        const type = types[Math.floor(Math.random() * types.length)];
        const ship = new Ship(shipId, type, city.nation, spawnX, spawnY);
        ship.homeCity = city;
        if (Math.random() < 0.5) {
          ship.behavior = 'trade';
          ship.tradeRoute = [city];
          let available = cities.filter(c => c.id !== city.id);
          while (ship.tradeRoute.length < 3 && available.length) {
            let next = available.splice(Math.floor(Math.random() * available.length), 1)[0];
            ship.tradeRoute.push(next);
          }
          ship.routeIndex = 1;
          ship.targetCity = ship.tradeRoute[1];
          logMessage(`${ship.nation} trade ship from ${city.name} bound for ${ship.targetCity.name}.`);
          ship.setCourse(ship.targetCity.x, ship.targetCity.y);
        } else {
          ship.behavior = 'patrol';
          const radius = 200;
          for (let i = 0; i < 4; i++) {
            const ang = (i / 4) * 2 * Math.PI;
            ship.patrolPoints.push({ x: city.x + Math.cos(ang) * radius, y: city.y + Math.sin(ang) * radius });
          }
          ship.patrolIndex = 0;
          const pt = ship.patrolPoints[0];
          logMessage(`${ship.nation} patrol ship guarding ${city.name}.`);
          ship.setCourse(pt.x, pt.y);
        }
        ships.push(ship);
        shipId++;
      }
    }
    
    let playerShip = null;
    function spawnPlayerShip() {
      const englishCities = cities.filter(c => c.nation === "England");
      let spawnCity = englishCities.length ? englishCities[Math.floor(Math.random() * englishCities.length)] : cities[0];
      let spawnX = spawnCity.x + Math.random() * 100 - 50;
      let spawnY = spawnCity.y + Math.random() * 100 - 50;
      for (let island of islands) {
        if (pointInPolygon(spawnX, spawnY, island.vertices)) {
          spawnX = spawnCity.x + 100;
          spawnY = spawnCity.y + 100;
          break;
        }
      }
      playerShip = new Ship(0, "Sloop", "England", spawnX, spawnY, true);
      playerShip.money = 100;
      ships.push(playerShip);
      logMessage("Player ship spawned near " + spawnCity.name);
    }
    
    /***********************
     * Game Mechanics & Updates
     ***********************/
    function updateCityEconomies(dt) {
      // Simulate simple supply/demand dynamics for each city.  Production and
      // consumption adjust quantities, while recent trade and scarcity affect
      // prices.
      for (let city of cities) {
        for (let goodName in city.goods) {
          const good = city.goods[goodName];

          // Apply local production and consumption.
          good.quantity += good.productionRate * dt;
          good.quantity -= good.consumptionRate * dt;

          // Apply player trade impact from since the last update.
          good.quantity += good.tradeVolume;

          // Adjust price based on trade volume: buying from the city (negative
          // tradeVolume) drives prices up, selling drives them down.
          if (good.tradeVolume !== 0) {
            good.price += (-good.tradeVolume) * 0.5;
          }
          good.tradeVolume = 0;

          // Clamp inventory within storage limits.
          if (good.quantity > good.maxStorage) good.quantity = good.maxStorage;
          if (good.quantity < 0) good.quantity = 0;

          // Scarcity influences price relative to the base price.
          const scarcity = 1 - (good.quantity / good.maxStorage);
          good.price = Math.max(
            1,
            good.basePrice * (1 + scarcity)
          );
        }
      }
    }
    
    function update(dt) {
      if (isPaused || inTradeMode) return;
      boardCandidate = null;
      for (let ship of ships) {
        ship.update(dt);
        if (playerShip && ship !== playerShip && !ship.captured &&
            distance(playerShip.x, playerShip.y, ship.x, ship.y) < 20) {
          boardCandidate = ship;
        }
      }
      for (let i = cannonballs.length - 1; i >= 0; i--) {
        const cb = cannonballs[i];
        cb.update(dt);
        if (cb.distanceTraveled > cb.range) { cannonballs.splice(i, 1); continue; }
        for (let ship of ships) {
          if (ship === cb.owner) continue;
          if (distance(cb.x, cb.y, ship.x, ship.y) < 15) {
            if (cb.damageType === "sail") {
              ship.sail = Math.max(0, ship.sail - cb.damage);
            } else {
              ship.hull = Math.max(0, ship.hull - cb.damage);
            }
            const casualties = Math.floor(Math.random() * 3);
            ship.crew = Math.max(0, ship.crew - casualties);
            logMessage((ship.isPlayer ? "Player" : ship.nation + " ship") +
              ` hit! Hull: ${ship.hull.toFixed(0)} Sails: ${ship.sail.toFixed(0)}`);
            cannonballs.splice(i, 1);
            break;
          }
        }
      }
      if (playerShip && (playerShip.hull <= 0 || playerShip.crew <= 0)) {
        let nearestCity = cities[0];
        let minDist = distance(playerShip.x, playerShip.y, cities[0].x, cities[0].y);
        for (let city of cities) {
          const d = distance(playerShip.x, playerShip.y, city.x, city.y);
          if (d < minDist) { minDist = d; nearestCity = city; }
        }
        logMessage("Player ship lost! Respawning at " + nearestCity.name);
        playerShip.x = nearestCity.x + 50;
        playerShip.y = nearestCity.y + 50;
        playerShip.type = "Sloop";
        playerShip.hull = playerShip.maxHull = 100;
        playerShip.sail = playerShip.maxSail = 100;
        playerShip.cannons = 2;
        playerShip.ammo = playerShip.maxAmmo = playerShip.cannons * 10;
        playerShip.money = 100;
        playerShip.crew = playerShip.maxCrew = 10;
      }
      updateCityEconomies(dt);
    }
    
    function draw() {
      let offsetX = playerShip ? playerShip.x - canvas.width / 2 : 0;
      let offsetY = playerShip ? playerShip.y - canvas.height / 2 : 0;
      offsetX = Math.max(0, Math.min(worldWidth - canvas.width, offsetX));
      offsetY = Math.max(0, Math.min(worldHeight - canvas.height, offsetY));
    
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      islands.forEach(island => island.draw(ctx, offsetX, offsetY));
      cities.forEach(city => city.draw(ctx, offsetX, offsetY));
      ships.forEach(ship => ship.draw(ctx, offsetX, offsetY));
      cannonballs.forEach(cb => cb.draw(ctx, offsetX, offsetY));
    
      if (playerShip) {
        hudDiv.innerHTML = `
          <p>Hull: ${playerShip.hull.toFixed(0)} / ${playerShip.maxHull}</p>
          <p>Sails: ${playerShip.sail.toFixed(0)} / ${playerShip.maxSail}</p>
          <p>Ammo: ${playerShip.ammo} / ${playerShip.maxAmmo}</p>
          <p>Crew: ${playerShip.crew} / ${playerShip.maxCrew}</p>
          <p>Money: ${playerShip.money}</p>
          <p>Ship: ${playerShip.type}</p>
          <p>Nation: ${playerShip.nation} ${nations[playerShip.nation]}</p>
          <p>Cannons: ${playerShip.cannons}</p>
          <p>Wind: ${windSpeed.toFixed(1)} @ ${(windDirection * 180/Math.PI).toFixed(0)}°</p>
        `;
        if (boardCandidate) {
          hudDiv.innerHTML += `<p>Press B to board!</p>`;
        }
      }
    
      updateQuestLogUI();
    
      if (showMinimap) {
        minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        const scale = minimapCanvas.width / worldWidth;
        minimapCtx.fillStyle = "#87CEEB";
        minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
        islands.forEach(island => island.drawMinimap(minimapCtx, scale));
        cities.forEach(city => city.drawMinimap(minimapCtx, scale));
        ships.forEach(ship => ship.drawMinimap(minimapCtx, scale));
        cannonballs.forEach(cb => cb.drawMinimap(minimapCtx, scale));
      }
    }
    
    function gameLoop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    /***********************
     * Input & Controls
     ***********************/
    document.addEventListener("keydown", (e) => {
      if (!inTradeMode) keys[e.key] = true;
      if (e.key === " ") {
        if (playerShip && playerShip.fireCooldown <= 0) {
          fireCannon(playerShip,
            playerShip.x + Math.cos(playerShip.angle) * 300,
            playerShip.y + Math.sin(playerShip.angle) * 300);
          playerShip.fireCooldown = 1;
        }
      }
      if (e.key.toLowerCase() === "p") {
        isPaused = !isPaused;
        logMessage(isPaused ? "Game Paused" : "Game Resumed");
      }
      if (e.key.toLowerCase() === "m") { showMinimap = !showMinimap; }
      if (e.key.toLowerCase() === "s") { saveGame(); }
      if (e.key.toLowerCase() === "l") { loadGame(); }
      if (e.key.toLowerCase() === "t") { toggleTradeMode(); }
      if (e.key.toLowerCase() === "c") { attemptCapture(); }
      if (e.key.toLowerCase() === "b") { attemptBoarding(); }
    });
    
    document.addEventListener("keyup", (e) => { keys[e.key] = false; });
    
    /***********************
     * Trading Mode
     ***********************/
    function toggleTradeMode() {
      if (!inTradeMode) {
        let nearbyCity = cities.find(city => distance(playerShip.x, playerShip.y, city.x, city.y) < 100);
        if (nearbyCity) {
          inTradeMode = true;
          isPaused = true;
          openTradeMenu(nearbyCity);
        } else { logMessage("Not near any city to trade."); }
      } else {
        inTradeMode = false;
        isPaused = false;
        closeTradeMenu();
      }
    }
    
    function openTradeMenu(city) {
      tradeMenuDiv.style.display = "block";

      // Build inventory list dynamically to reflect current prices and
      // quantities that may fluctuate over time.
      const inventory = Object.entries(city.goods)
        .map(([name, data]) => `<li>${name}: ${data.quantity.toFixed(0)} @ ${data.price.toFixed(0)}</li>`)
        .join("");

      tradeMenuDiv.innerHTML = `
        <h3>Trading at ${city.name} (${city.nation} ${nations[city.nation]})</h3>
        <p>Your Money: ${playerShip.money}</p>
        <p>Reputation with ${city.nation}: ${playerReputation[city.nation]}</p>
        <p>City Inventory:</p>
        <ul>${inventory}</ul>
        <p>Controls:</p>
        <p>Buy: 1 (Rum), 2 (Spices), 3 (Gold)</p>
        <p>Sell: Q (Rum), W (Spices), E (Gold)</p>
        <p>Buy Cannon: 4 | Recruit Crew: R</p>
        <p>Sell Captured Ship: V | Sell Cannon: Y</p>
        <p>Visit Governor: G | Accept Mission: M</p>
        <p>Refit Ship: F | Hire Specialists: H</p>
        <p>Press T to exit trading.</p>
      `;
    }

    function closeTradeMenu() {
      tradeMenuDiv.style.display = "none";
      governorMenuDiv.style.display = "none";
      upgradeMenuDiv.style.display = "none";
    }

    function openGovernorMenu(city) {
      governorMenuDiv.style.display = "block";
      governorMenuDiv.innerHTML = `
        <h3>Governor of ${city.name}</h3>
        <p>Nation: ${city.nation} ${nations[city.nation]}</p>
        <p>Your Reputation: ${playerReputation[city.nation]}</p>
        <p>M: Accept Mission (Rep ≥ 10)</p>
        <p>L: Request Letter of Marque (Rep ≥ 20)</p>
        <p>Esc: Exit</p>
      `;
    }

    function closeGovernorMenu() { governorMenuDiv.style.display = "none"; }

    function openUpgradeMenu(city) {
      upgradeMenuDiv.style.display = "block";
      upgradeMenuDiv.innerHTML = `
        <h3>Shipyard at ${city.name}</h3>
        <p>Money: ${playerShip.money}</p>
        <p>1: Upgrade Hull (100 gold)</p>
        <p>2: Upgrade Sails (100 gold)</p>
        <p>3: Hire Navigator (50 gold)</p>
        <p>4: Hire Gunner (50 gold)</p>
        <p>Esc: Exit</p>
      `;
    }

    function closeUpgradeMenu() { upgradeMenuDiv.style.display = "none"; }

    function acceptMissionFromCity(city) {
      if (playerReputation[city.nation] < 10) {
        logMessage("Reputation too low for missions.");
        return;
      }
      if (cities.length < 2) return;
      let target;
      do {
        target = cities[Math.floor(Math.random() * cities.length)];
      } while (target.id === city.id);
      const goods = ["Rum", "Spices", "Gold"];
      const good = goods[Math.floor(Math.random() * goods.length)];
      const amount = Math.floor(Math.random() * 3) + 1;
      const reward = Math.floor(Math.random() * 100) + 50;
      const quest = new Quest(Date.now(), "delivery", city, target, good, amount, reward);
      quests.push(quest);
      logMessage("Mission accepted: " + quest.description);
      updateQuestLogUI();
    }

    function requestLetterOfMarque(city) {
      if (playerReputation[city.nation] < 20) {
        logMessage("Reputation too low for letter of marque.");
        return;
      }
      if (lettersOfMarque[city.nation]) {
        logMessage("Letter of marque already granted.");
        return;
      }
      lettersOfMarque[city.nation] = true;
      logMessage(`${city.nation} grants you a letter of marque!`);
    }
    
    document.addEventListener("keydown", (e) => {
      if (inTradeMode) {
        let currentCity = cities.find(city => distance(playerShip.x, playerShip.y, city.x, city.y) < 100);
        if (!currentCity) return;

        if (governorMenuDiv.style.display === "block") {
          switch (e.key.toLowerCase()) {
            case "m":
              acceptMissionFromCity(currentCity);
              break;
            case "l":
              requestLetterOfMarque(currentCity);
              break;
            case "escape":
              closeGovernorMenu();
              break;
          }
          return;
        }

        if (upgradeMenuDiv.style.display === "block") {
          switch (e.key) {
            case "1":
              if (playerShip.money >= 100) {
                playerShip.money -= 100;
                playerShip.maxHull += 20;
                playerShip.hull = playerShip.maxHull;
                logMessage("Hull upgraded.");
              }
              break;
            case "2":
              if (playerShip.money >= 100) {
                playerShip.money -= 100;
                playerShip.maxSail += 20;
                playerShip.sail = playerShip.maxSail;
                logMessage("Sails upgraded.");
              }
              break;
            case "3":
              if (playerShip.money >= 50 && !playerShip.specialists.includes('Navigator')) {
                playerShip.money -= 50;
                playerShip.specialists.push('Navigator');
                playerShip.maxSpeed += 0.2;
                logMessage("Navigator hired.");
              }
              break;
            case "4":
              if (playerShip.money >= 50 && !playerShip.specialists.includes('Gunner')) {
                playerShip.money -= 50;
                playerShip.specialists.push('Gunner');
                playerShip.cannons++;
                playerShip.maxAmmo = playerShip.cannons * 10;
                playerShip.ammo = playerShip.maxAmmo;
                logMessage("Gunner hired.");
              }
              break;
            case "Escape":
              closeUpgradeMenu();
              break;
          }
          if (upgradeMenuDiv.style.display === "block") openUpgradeMenu(currentCity);
          return;
        }

        switch (e.key) {
          case "1":
            if (playerShip.money >= currentCity.goods["Rum"].price && currentCity.goods["Rum"].quantity > 0) {
              playerShip.money -= currentCity.goods["Rum"].price;
              playerShip.inventory["Rum"] = (playerShip.inventory["Rum"] || 0) + 1;
              currentCity.goods["Rum"].quantity--;
              currentCity.goods["Rum"].tradeVolume--;
              playerReputation[currentCity.nation]++;
              logMessage("Bought 1 Rum.");
            }
            break;
          case "2":
            if (playerShip.money >= currentCity.goods["Spices"].price && currentCity.goods["Spices"].quantity > 0) {
              playerShip.money -= currentCity.goods["Spices"].price;
              playerShip.inventory["Spices"] = (playerShip.inventory["Spices"] || 0) + 1;
              currentCity.goods["Spices"].quantity--;
              currentCity.goods["Spices"].tradeVolume--;
              playerReputation[currentCity.nation]++;
              logMessage("Bought 1 Spices.");
            }
            break;
          case "3":
            if (playerShip.money >= currentCity.goods["Gold"].price && currentCity.goods["Gold"].quantity > 0) {
              playerShip.money -= currentCity.goods["Gold"].price;
              playerShip.inventory["Gold"] = (playerShip.inventory["Gold"] || 0) + 1;
              currentCity.goods["Gold"].quantity--;
              currentCity.goods["Gold"].tradeVolume--;
              playerReputation[currentCity.nation]++;
              logMessage("Bought 1 Gold.");
            }
            break;
          case "q":
          case "Q":
            if ((playerShip.inventory["Rum"] || 0) > 0) {
              playerShip.money += currentCity.goods["Rum"].price;
              playerShip.inventory["Rum"]--;
              currentCity.goods["Rum"].quantity++;
              currentCity.goods["Rum"].tradeVolume++;
              playerReputation[currentCity.nation]++;
              logMessage("Sold 1 Rum.");
            }
            break;
          case "w":
          case "W":
            if ((playerShip.inventory["Spices"] || 0) > 0) {
              playerShip.money += currentCity.goods["Spices"].price;
              playerShip.inventory["Spices"]--;
              currentCity.goods["Spices"].quantity++;
              currentCity.goods["Spices"].tradeVolume++;
              playerReputation[currentCity.nation]++;
              logMessage("Sold 1 Spices.");
            }
            break;
          case "e":
          case "E":
            if ((playerShip.inventory["Gold"] || 0) > 0) {
              playerShip.money += currentCity.goods["Gold"].price;
              playerShip.inventory["Gold"]--;
              currentCity.goods["Gold"].quantity++;
              currentCity.goods["Gold"].tradeVolume++;
              playerReputation[currentCity.nation]++;
              logMessage("Sold 1 Gold.");
            }
            break;
          case "4":
            if (playerShip.money >= 50) {
              playerShip.money -= 50;
              playerShip.cannons++;
              logMessage("Bought a Cannon.");
            }
            break;
          case "r":
          case "R":
            if (playerShip.money >= 10) {
              playerShip.money -= 10;
              playerShip.crew += 5;
              logMessage("Recruited 5 Crew members.");
            }
            break;
          case "v":
          case "V":
            let capturedIndex = ships.findIndex(s => s.captured);
            if (capturedIndex !== -1) {
              playerShip.money += 100;
              ships.splice(capturedIndex, 1);
              logMessage("Sold captured ship for 100 gold.");
            }
            break;
          case "y":
          case "Y":
            if (playerShip.cannons > 0) {
              playerShip.cannons--;
              playerShip.money += 30;
              logMessage("Sold a Cannon for 30 gold.");
            }
            break;
          case "g":
          case "G":
            openGovernorMenu(currentCity);
            break;
          case "m":
          case "M":
            acceptMissionFromCity(currentCity);
            break;
          case "f":
          case "F":
            openUpgradeMenu(currentCity);
            break;
          case "h":
          case "H":
            openUpgradeMenu(currentCity);
            break;
        }
        openTradeMenu(currentCity);
      }
    });
    
    /***********************
     * Boarding Sequence
     ***********************/
    function attemptBoarding() {
      if (!boardCandidate) { logMessage("No ship to board."); return; }
      const enemy = boardCandidate;
      logMessage("Boarding " + enemy.nation + " ship!");
      while (playerShip.crew > 0 && enemy.crew > 0) {
        enemy.crew -= Math.floor(Math.random() * 3) + 1;
        playerShip.crew -= Math.floor(Math.random() * 3) + 1;
      }
      if (playerShip.crew > 0) {
        enemy.captured = true;
        enemy.nation = playerShip.nation;
        logMessage("Enemy ship captured!");
      } else {
        logMessage("Your crew was defeated!");
        playerShip.hull = 0;
      }
      boardCandidate = null;
    }

    /***********************
     * Capturing Enemy Ships
     ***********************/
    function attemptCapture() {
      for (let ship of ships) {
        if (!ship.isPlayer && !ship.captured && distance(playerShip.x, playerShip.y, ship.x, ship.y) < 50 && ship.hull < 15) {
          const choice = confirm("Capture enemy ship: OK to take over, Cancel to sink.");
          if (choice) {
            ship.captured = true;
            ship.nation = playerShip.nation;
            logMessage("Captured enemy ship!");
          } else {
            playerShip.money += 50;
            logMessage("Sunk enemy ship for loot!");
            ships = ships.filter(s => s !== ship);
          }
          break;
        }
      }
    }
    
    /***********************
     * Saving & Loading (with Rehydration)
     ***********************/
    function saveGame() {
      const state = {
        islands,
        cities,
        ships,
        cannonballs,
        playerShip,
        quests,
        relationships,
        playerReputation,
        lettersOfMarque,
        storyMilestones
      };

      // Ensure all economic fields on goods are persisted.
      state.cities.forEach(city => {
        Object.values(city.goods).forEach(good => {
          if (good.tradeVolume === undefined) good.tradeVolume = 0;
          if (good.productionRate === undefined) good.productionRate = 0;
          if (good.consumptionRate === undefined) good.consumptionRate = 0;
          if (good.maxStorage === undefined) good.maxStorage = 0;
          if (good.basePrice === undefined) good.basePrice = good.price;
        });
      });

      localStorage.setItem("pirateGameSave", JSON.stringify(state));
      logMessage("Game saved.");
    }
    
    function loadGame() {
      const stateStr = localStorage.getItem("pirateGameSave");
      if (stateStr) {
        const state = JSON.parse(stateStr);
        islands = state.islands;
        cities = state.cities;
        ships = state.ships;
        cannonballs = state.cannonballs;
        quests = state.quests || [];
        playerShip = ships.find(s => s.isPlayer);
        relationships = state.relationships;
        playerReputation = state.playerReputation || {};
        lettersOfMarque = state.lettersOfMarque || {};
        storyMilestones = state.storyMilestones || {};
        islands.forEach(i => Object.setPrototypeOf(i, Island.prototype));
        cities.forEach(c => {
          Object.setPrototypeOf(c, City.prototype);
          // Restore economy fields for each good, providing defaults for older saves.
          Object.values(c.goods).forEach(good => {
            if (good.tradeVolume === undefined) good.tradeVolume = 0;
            if (good.productionRate === undefined) good.productionRate = 0;
            if (good.consumptionRate === undefined) good.consumptionRate = 0;
            if (good.maxStorage === undefined) good.maxStorage = 100;
            if (good.basePrice === undefined) good.basePrice = good.price;
          });
        });
        ships.forEach(s => Object.setPrototypeOf(s, Ship.prototype));
        cannonballs.forEach(cb => Object.setPrototypeOf(cb, Cannonball.prototype));
        quests.forEach(q => Object.setPrototypeOf(q, Quest.prototype));
        // Ensure reputation and marque objects have all nations
        Object.keys(nations).forEach(n => {
          if (playerReputation[n] === undefined) playerReputation[n] = 0;
          if (lettersOfMarque[n] === undefined) lettersOfMarque[n] = false;
        });
        logMessage("Game loaded.");
        updateQuestLogUI();
      } else {
        logMessage("No saved game found.");
      }
    }
    
    /***********************
     * Initialization & Loop Start
     ***********************/
    function initGame() {
      initRelationships();
      initReputation();
      generateIslands();
      generateCities();
      generateEnemyShips();
      spawnPlayerShip();
      requestAnimationFrame(gameLoop);
    }
    
    initGame();
    
    // Generate a new quest every 60 seconds.
    setInterval(generateRandomQuest, 60000);
    
    /***********************
     * Main Game Loop
     ***********************/
    function gameLoop(timestamp) {
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
