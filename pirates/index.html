<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pirate Game</title>
  <style>
    /* Page & Canvas styling */
    body {
      margin: 0;
      background: #87CEEB;
      font-family: sans-serif;
      overflow: hidden;
    }
    #gameCanvas {
      border: 2px solid black;
      background: #87CEEB;
      display: block;
    }
    /* Minimap container in upper-right */
    #minimapContainer {
      position: absolute;
      top: 10px;
      right: 10px;
      border: 1px solid #000;
      background: rgba(255,255,255,0.7);
      width: 200px;
      height: 200px;
    }
    /* HUD in top-left, below minimap */
    #hud {
      position: absolute;
      top: 220px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 5px;
      font-size: 14px;
    }
    /* Log console at bottom */
    #log {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      background: rgba(0,0,0,0.8);
      color: #0f0;
      font-family: monospace;
      overflow-y: auto;
      padding: 5px;
      box-sizing: border-box;
    }
    /* Trade menu overlay (hidden by default) */
    #tradeMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: #fff;
      padding: 20px;
      border: 2px solid #fff;
      display: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <!-- Main game canvas (800Ã—600) -->
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <!-- Minimap canvas (200Ã—200) -->
  <div id="minimapContainer">
    <canvas id="minimap" width="200" height="200"></canvas>
  </div>
  <!-- HUD display -->
  <div id="hud"></div>
  <!-- Debug log console -->
  <div id="log"></div>
  <!-- Trade Menu (shown when trading) -->
  <div id="tradeMenu"></div>
  
  <script>
    /***********************
     * Global Game Settings
     ***********************/
    const worldWidth = 2400, worldHeight = 1600;
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const hudDiv = document.getElementById('hud');
    const logDiv = document.getElementById('log');
    const tradeMenuDiv = document.getElementById('tradeMenu');
    
    let lastTime = 0;
    let isPaused = false;
    let inTradeMode = false;
    let showMinimap = true;
    
    // Arrays to hold game objects
    let islands = [];
    let cities = [];
    let ships = [];
    let cannonballs = [];
    
    // Key tracking
    const keys = {};
    
    // Define nations and their Unicode flags
    const nations = {
      "Netherlands": "ðŸ‡³ðŸ‡±", // (U+1F1F3 U+1F1F1)
      "Spain":      "ðŸ‡ªðŸ‡¸", // (U+1F1EA U+1F1F8)
      "France":     "ðŸ‡«ðŸ‡·", // (U+1F1EB U+1F1F7)
      "England":    "ðŸ‡¬ðŸ‡§"  // (U+1F1EC U+1F1E7)
    };
    
    // Relationships: each key "NationA-NationB" (alphabetical order) maps to "peace" or "war"
    let relationships = {};
    function initRelationships() {
      const nationKeys = Object.keys(nations);
      for (let i = 0; i < nationKeys.length; i++) {
        for (let j = i + 1; j < nationKeys.length; j++) {
          const key = nationKeys[i] + '-' + nationKeys[j];
          relationships[key] = Math.random() < 0.5 ? 'peace' : 'war';
        }
      }
      logMessage("Initial relationships set.");
    }
    // Every 120 seconds randomly toggle relationships
    setInterval(() => {
      const nationKeys = Object.keys(nations);
      for (let i = 0; i < nationKeys.length; i++) {
        for (let j = i + 1; j < nationKeys.length; j++) {
          const key = nationKeys[i] + '-' + nationKeys[j];
          relationships[key] = Math.random() < 0.5 ? 'peace' : 'war';
          logMessage(`Relationship between ${nationKeys[i]} and ${nationKeys[j]} is now ${relationships[key]}.`);
        }
      }
    }, 120000);
    
    function areAtWar(nationA, nationB) {
      if(nationA === nationB) return false;
      const sorted = [nationA, nationB].sort();
      return relationships[sorted[0] + '-' + sorted[1]] === 'war';
    }
    
    /***********************
     * Utility Functions
     ***********************/
    function logMessage(message) {
      const p = document.createElement('p');
      p.textContent = message;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    function distance(x1, y1, x2, y2) {
      return Math.hypot(x2 - x1, y2 - y1);
    }
    
    // Point in polygon using rayâ€“casting algorithm
    function pointInPolygon(x, y, vertices) {
      let inside = false;
      for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x, yi = vertices[i].y;
        const xj = vertices[j].x, yj = vertices[j].y;
        const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    
    // Normalize an angle to (â€“PI, PI)
    function normalizeAngle(angle) {
      while (angle > Math.PI) angle -= 2*Math.PI;
      while (angle < -Math.PI) angle += 2*Math.PI;
      return angle;
    }
    
    // Random integer price between min and max
    function randomPrice(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    /***********************
     * Object Classes
     ***********************/
    class Island {
      constructor(vertices) {
        this.vertices = vertices; // Array of {x,y}
        this.city = null; // Will be set later
      }
      draw(ctx, offsetX, offsetY) {
        ctx.fillStyle = "#228B22";
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x - offsetX, this.vertices[0].y - offsetY);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.vertices[i].x - offsetX, this.vertices[i].y - offsetY);
        }
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = "#006400";
        ctx.stroke();
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = "#228B22";
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x * scale, this.vertices[0].y * scale);
        for (let i = 1; i < this.vertices.length; i++) {
          ctx.lineTo(this.vertices[i].x * scale, this.vertices[i].y * scale);
        }
        ctx.closePath();
        ctx.fill();
      }
    }
    
    class City {
      constructor(id, name, x, y, nation) {
        this.id = id;
        this.name = name;
        this.x = x;
        this.y = y;
        this.nation = nation;
        this.population = 1000;
        this.goods = {
          "Rum": { price: randomPrice(10,20), quantity: 100 },
          "Spices": { price: randomPrice(15,30), quantity: 100 },
          "Gold": { price: randomPrice(50,100), quantity: 50 }
        };
      }
      draw(ctx, offsetX, offsetY) {
        ctx.font = "16px sans-serif";
        ctx.fillText("ðŸ ", this.x - offsetX - 8, this.y - offsetY + 8);
        // Draw a small flag beside the city
        ctx.font = "12px sans-serif";
        ctx.fillText(nations[this.nation], this.x - offsetX + 8, this.y - offsetY - 8);
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = "black";
        ctx.fillText("ðŸ ", this.x * scale - 6, this.y * scale + 6);
        ctx.fillText(nations[this.nation], this.x * scale + 6, this.y * scale - 6);
      }
    }
    
    class Ship {
      constructor(id, type, nation, x, y, isPlayer = false) {
        this.id = id;
        this.type = type;
        this.nation = nation;
        this.x = x;
        this.y = y;
        this.angle = Math.random() * 2 * Math.PI;
        this.speed = 0;
        this.maxSpeed = type === "Sloop" ? 2 : type === "Brig" ? 1.5 : 1;
        this.health = type === "Sloop" ? 100 : type === "Brig" ? 150 : 200;
        this.maxHealth = this.health;
        this.inventory = { "Rum": 0, "Spices": 0, "Gold": 0 };
        this.cannons = type === "Sloop" ? 2 : type === "Brig" ? 4 : 8;
        this.crew = type === "Sloop" ? 10 : type === "Brig" ? 20 : 30;
        this.isPlayer = isPlayer;
        this.targetCity = null; // For enemy trade route
        this.homeCity = null;
        this.fireCooldown = 0;
        this.captured = false;  // Flag for captured enemy ship
        this.money = 0; // For player only
      }
      update(dt) {
        if (this.isPlayer) {
          // Use arrow keys to rotate and move
          if (keys["ArrowLeft"]) this.angle -= 0.05;
          if (keys["ArrowRight"]) this.angle += 0.05;
          if (keys["ArrowUp"]) this.speed = this.maxSpeed;
          else this.speed = 0;
        } else {
          // Simple AI: steer toward targetCity (if set)
          if (this.targetCity) {
            const desiredAngle = Math.atan2(this.targetCity.y - this.y, this.targetCity.x - this.x);
            const angleDiff = normalizeAngle(desiredAngle - this.angle);
            if (angleDiff > 0.1) this.angle += 0.03;
            else if (angleDiff < -0.1) this.angle -= 0.03;
            else this.angle = desiredAngle;
            this.speed = this.maxSpeed * 0.8;
          } else {
            this.speed = this.maxSpeed * 0.5;
          }
        }
        // Attempt to move; avoid islands by checking if new point would be on land
        const newX = this.x + Math.cos(this.angle) * this.speed;
        const newY = this.y + Math.sin(this.angle) * this.speed;
        let collision = false;
        for (let island of islands) {
          if (pointInPolygon(newX, newY, island.vertices)) {
            collision = true;
            break;
          }
        }
        if (!collision) { this.x = newX; this.y = newY; }
        if (this.fireCooldown > 0) this.fireCooldown -= dt;
    
        // Enemy ships auto-fire at the player if in range and at war
        if (!this.isPlayer && !inTradeMode && this.fireCooldown <= 0 && playerShip) {
          const d = distance(this.x, this.y, playerShip.x, playerShip.y);
          if (d < 300 && areAtWar(this.nation, playerShip.nation)) {
            fireCannon(this, playerShip.x, playerShip.y);
            this.fireCooldown = 2; // 2-second cooldown
          }
        }
      }
      draw(ctx, offsetX, offsetY) {
        ctx.save();
        ctx.translate(this.x - offsetX, this.y - offsetY);
        ctx.rotate(this.angle);
        ctx.font = "20px serif";
        ctx.fillText("â›µ", -10, 10);
        ctx.restore();
        // Draw small flag near the ship
        ctx.font = "12px sans-serif";
        ctx.fillText(nations[this.nation], this.x - offsetX + 15, this.y - offsetY - 15);
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = this.isPlayer ? "blue" : "red";
        ctx.beginPath();
        ctx.arc(this.x * scale, this.y * scale, 3, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
    
    class Cannonball {
      constructor(x, y, angle, owner) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = 5;
        this.damage = 20;
        this.range = 300;
        this.distanceTraveled = 0;
        this.owner = owner;
      }
      update(dt) {
        const dx = Math.cos(this.angle) * this.speed;
        const dy = Math.sin(this.angle) * this.speed;
        this.x += dx;
        this.y += dy;
        this.distanceTraveled += Math.hypot(dx,dy);
      }
      draw(ctx, offsetX, offsetY) {
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(this.x - offsetX, this.y - offsetY, 5, 0, 2 * Math.PI); // ~10px diameter
        ctx.fill();
      }
      drawMinimap(ctx, scale) {
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(this.x * scale, this.y * scale, 2, 0, 2 * Math.PI);
        ctx.fill();
      }
    }
    
    // Fire a cannonball from a given ship toward a target (x,y)
    function fireCannon(ship, targetX, targetY) {
      const angle = Math.atan2(targetY - ship.y, targetX - ship.x);
      const cannonball = new Cannonball(
        ship.x + Math.cos(angle)*20,
        ship.y + Math.sin(angle)*20,
        angle,
        ship
      );
      cannonballs.push(cannonball);
      logMessage((ship.isPlayer ? "Player" : ship.nation + " ship") + " fired a cannonball.");
    }
    
    /***********************
     * World Generation
     ***********************/
    // Generate 20 islands with random polygonal shapes.
    function generateIslands() {
      islands = [];
      for (let i = 0; i < 20; i++) {
        const cx = Math.random() * (worldWidth - 200) + 100;
        const cy = Math.random() * (worldHeight - 200) + 100;
        const numPoints = Math.floor(Math.random() * 5) + 5; // 5-9 vertices
        const vertices = [];
        for (let j = 0; j < numPoints; j++) {
          const angle = (j / numPoints) * 2 * Math.PI;
          const radius = Math.random() * 50 + 30;
          const x = cx + Math.cos(angle) * radius + (Math.random()-0.5)*20;
          const y = cy + Math.sin(angle) * radius + (Math.random()-0.5)*20;
          vertices.push({x, y});
        }
        islands.push(new Island(vertices));
      }
    }
    
    // Place one city on each island (using one of the islandâ€™s vertices)
    function generateCities() {
      cities = [];
      let cityId = 1;
      for (let island of islands) {
        const vertex = island.vertices[Math.floor(Math.random() * island.vertices.length)];
        const nationKeys = Object.keys(nations);
        const nation = nationKeys[Math.floor(Math.random() * nationKeys.length)];
        const city = new City(cityId, "City " + cityId, vertex.x, vertex.y, nation);
        cities.push(city);
        island.city = city;
        cityId++;
      }
    }
    
    // Spawn enemy ships near each city (making sure they appear in water)
    function generateEnemyShips() {
      // Remove any old enemy ships (keep the playerâ€™s ship)
      ships = ships.filter(s => s.isPlayer);
      let shipId = 1;
      for (let city of cities) {
        let spawnX = city.x + Math.random()*100 - 50;
        let spawnY = city.y + Math.random()*100 - 50;
        // If by chance the spawn point is on an island, adjust it
        let onLand = false;
        for (let island of islands) {
          if (pointInPolygon(spawnX, spawnY, island.vertices)) {
            onLand = true;
            break;
          }
        }
        if (onLand) { spawnX = city.x + 100; spawnY = city.y + 100; }
        const types = ["Sloop", "Brig", "Galleon"];
        const type = types[Math.floor(Math.random()*types.length)];
        const ship = new Ship(shipId, type, city.nation, spawnX, spawnY);
        ship.homeCity = city;
        // Choose a random target city (different from home) as the trade route destination
        let possibleTargets = cities.filter(c => c.id !== city.id);
        ship.targetCity = possibleTargets[Math.floor(Math.random()*possibleTargets.length)];
        ships.push(ship);
        shipId++;
      }
    }
    
    // Spawn the playerâ€™s ship near an English city (if available) in a water location.
    let playerShip = null;
    function spawnPlayerShip() {
      const englishCities = cities.filter(c => c.nation === "England");
      let spawnCity = englishCities.length ? englishCities[Math.floor(Math.random()*englishCities.length)] : cities[0];
      let spawnX = spawnCity.x + Math.random()*100 - 50;
      let spawnY = spawnCity.y + Math.random()*100 - 50;
      // Ensure the spawn is in water (if on land, adjust)
      for (let island of islands) {
        if (pointInPolygon(spawnX, spawnY, island.vertices)) {
          spawnX = spawnCity.x + 100;
          spawnY = spawnCity.y + 100;
          break;
        }
      }
      playerShip = new Ship(0, "Sloop", "England", spawnX, spawnY, true);
      playerShip.money = 100; // starting gold
      ships.push(playerShip);
      logMessage("Player ship spawned near " + spawnCity.name);
    }
    
    /***********************
     * Game Mechanics & Updates
     ***********************/
    // Update city economies: prices fluctuate slightly over time.
    function updateCityEconomies(dt) {
      for (let city of cities) {
        for (let good in city.goods) {
          let change = (Math.random()-0.5)*dt*0.1;
          city.goods[good].price = Math.max(1, city.goods[good].price + change);
        }
      }
    }
    
    // Main update function â€“ moves ships, cannonballs, checks collisions, etc.
    function update(dt) {
      if (isPaused || inTradeMode) return;
      for (let ship of ships) { ship.update(dt); }
      for (let i = cannonballs.length-1; i >= 0; i--) {
        const cb = cannonballs[i];
        cb.update(dt);
        if (cb.distanceTraveled > cb.range) { cannonballs.splice(i, 1); continue; }
        // Check collision with ships (except the one that fired the cannonball)
        for (let ship of ships) {
          if (ship === cb.owner) continue;
          if (distance(cb.x, cb.y, ship.x, ship.y) < 15) {
            ship.health -= cb.damage;
            logMessage((ship.isPlayer ? "Player" : ship.nation + " ship") + " hit! HP: " + ship.health.toFixed(0));
            cannonballs.splice(i, 1);
            break;
          }
        }
      }
      // If the playerâ€™s ship is destroyed, respawn at the nearest city.
      if (playerShip && playerShip.health <= 0) {
        let nearestCity = cities[0];
        let minDist = distance(playerShip.x, playerShip.y, cities[0].x, cities[0].y);
        for (let city of cities) {
          const d = distance(playerShip.x, playerShip.y, city.x, city.y);
          if (d < minDist) { minDist = d; nearestCity = city; }
        }
        logMessage("Player ship destroyed! Respawning at " + nearestCity.name);
        playerShip.x = nearestCity.x + 50;
        playerShip.y = nearestCity.y + 50;
        playerShip.health = 100;
        playerShip.type = "Sloop";
        playerShip.money = 100;
        playerShip.crew = 10;
      }
      updateCityEconomies(dt);
    }
    
    // Draw the game world and UI elements.
    function draw() {
      // Camera: center on playerShip (clamped within world boundaries)
      let offsetX = playerShip ? playerShip.x - canvas.width/2 : 0;
      let offsetY = playerShip ? playerShip.y - canvas.height/2 : 0;
      offsetX = Math.max(0, Math.min(worldWidth - canvas.width, offsetX));
      offsetY = Math.max(0, Math.min(worldHeight - canvas.height, offsetY));
    
      // Clear main canvas (sea/sky background)
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(0,0, canvas.width, canvas.height);
      // Draw islands, cities, ships, and cannonballs
      islands.forEach(island => island.draw(ctx, offsetX, offsetY));
      cities.forEach(city => city.draw(ctx, offsetX, offsetY));
      ships.forEach(ship => ship.draw(ctx, offsetX, offsetY));
      cannonballs.forEach(cb => cb.draw(ctx, offsetX, offsetY));
    
      // Update HUD with player info
      if (playerShip) {
        hudDiv.innerHTML = `
          <p>HP: ${playerShip.health.toFixed(0)} / 100</p>
          <p>Money: ${playerShip.money}</p>
          <p>Crew: ${playerShip.crew}</p>
          <p>Ship: ${playerShip.type}</p>
          <p>Nation: ${playerShip.nation} ${nations[playerShip.nation]}</p>
          <p>Cannons: ${playerShip.cannons}</p>
        `;
      }
    
      // Draw minimap if toggled on
      if (showMinimap) {
        minimapCtx.clearRect(0,0, minimapCanvas.width, minimapCanvas.height);
        const scale = minimapCanvas.width / worldWidth;
        minimapCtx.fillStyle = "#87CEEB";
        minimapCtx.fillRect(0,0, minimapCanvas.width, minimapCanvas.height);
        islands.forEach(island => island.drawMinimap(minimapCtx, scale));
        cities.forEach(city => city.drawMinimap(minimapCtx, scale));
        ships.forEach(ship => ship.drawMinimap(minimapCtx, scale));
        cannonballs.forEach(cb => cb.drawMinimap(minimapCtx, scale));
      }
    }
    
    // The main game loop using requestAnimationFrame.
    function gameLoop(timestamp) {
      const dt = (timestamp - lastTime)/1000;
      lastTime = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }
    
    /***********************
     * Input & Controls
     ***********************/
    document.addEventListener("keydown", (e) => {
      // Record key state (unless in trade mode)
      if (!inTradeMode) keys[e.key] = true;
    
      // Fire cannon with Space (if cooldown allows)
      if (e.key === " ") {
        if (playerShip && playerShip.fireCooldown <= 0) {
          fireCannon(playerShip,
            playerShip.x + Math.cos(playerShip.angle)*300,
            playerShip.y + Math.sin(playerShip.angle)*300);
          playerShip.fireCooldown = 1;
        }
      }
      // P: pause/unpause
      if (e.key.toLowerCase() === "p") {
        isPaused = !isPaused;
        logMessage(isPaused ? "Game Paused" : "Game Resumed");
      }
      // M: toggle minimap
      if (e.key.toLowerCase() === "m") { showMinimap = !showMinimap; }
      // S: Save game
      if (e.key.toLowerCase() === "s") { saveGame(); }
      // L: Load game
      if (e.key.toLowerCase() === "l") { loadGame(); }
      // T: Initiate/exit trading (if near a city)
      if (e.key.toLowerCase() === "t") { toggleTradeMode(); }
      // C: Attempt to capture an enemy ship (if conditions met)
      if (e.key.toLowerCase() === "c") { attemptCapture(); }
    });
    
    document.addEventListener("keyup", (e) => { keys[e.key] = false; });
    
    /***********************
     * Trading Mode
     ***********************/
    // Toggle trade mode (only allowed when near a city)
    function toggleTradeMode() {
      if (!inTradeMode) {
        let nearbyCity = cities.find(city => distance(playerShip.x, playerShip.y, city.x, city.y) < 100);
        if (nearbyCity) {
          inTradeMode = true;
          isPaused = true;
          openTradeMenu(nearbyCity);
        } else { logMessage("Not near any city to trade."); }
      } else {
        inTradeMode = false;
        isPaused = false;
        closeTradeMenu();
      }
    }
    
    function openTradeMenu(city) {
      tradeMenuDiv.style.display = "block";
      tradeMenuDiv.innerHTML = `
        <h3>Trading at ${city.name} (${city.nation} ${nations[city.nation]})</h3>
        <p>Your Money: ${playerShip.money}</p>
        <p>City Inventory:</p>
        <ul>
          <li>Rum: ${city.goods["Rum"].quantity} @ ${city.goods["Rum"].price.toFixed(0)}</li>
          <li>Spices: ${city.goods["Spices"].quantity} @ ${city.goods["Spices"].price.toFixed(0)}</li>
          <li>Gold: ${city.goods["Gold"].quantity} @ ${city.goods["Gold"].price.toFixed(0)}</li>
        </ul>
        <p>Controls:</p>
        <p>Buy: 1 (Rum), 2 (Spices), 3 (Gold)</p>
        <p>Sell: Q (Rum), W (Spices), E (Gold)</p>
        <p>Buy Cannon: 4 | Recruit Crew: R</p>
        <p>Sell Captured Ship: V | Sell Cannon: Y</p>
        <p>Press T to exit trading.</p>
      `;
    }
    
    function closeTradeMenu() {
      tradeMenuDiv.style.display = "none";
    }
    
    // Listen for trade key commands while in trade mode.
    document.addEventListener("keydown", (e) => {
      if (inTradeMode) {
        // Find the city the player is trading with (must be nearby)
        let currentCity = cities.find(city => distance(playerShip.x, playerShip.y, city.x, city.y) < 100);
        if (!currentCity) return;
        switch(e.key) {
          case "1": // Buy Rum
            if (playerShip.money >= currentCity.goods["Rum"].price && currentCity.goods["Rum"].quantity > 0) {
              playerShip.money -= currentCity.goods["Rum"].price;
              playerShip.inventory["Rum"] = (playerShip.inventory["Rum"] || 0) + 1;
              currentCity.goods["Rum"].quantity--;
              logMessage("Bought 1 Rum.");
            }
            break;
          case "2": // Buy Spices
            if (playerShip.money >= currentCity.goods["Spices"].price && currentCity.goods["Spices"].quantity > 0) {
              playerShip.money -= currentCity.goods["Spices"].price;
              playerShip.inventory["Spices"] = (playerShip.inventory["Spices"] || 0) + 1;
              currentCity.goods["Spices"].quantity--;
              logMessage("Bought 1 Spices.");
            }
            break;
          case "3": // Buy Gold
            if (playerShip.money >= currentCity.goods["Gold"].price && currentCity.goods["Gold"].quantity > 0) {
              playerShip.money -= currentCity.goods["Gold"].price;
              playerShip.inventory["Gold"] = (playerShip.inventory["Gold"] || 0) + 1;
              currentCity.goods["Gold"].quantity--;
              logMessage("Bought 1 Gold.");
            }
            break;
          case "q":
          case "Q": // Sell Rum
            if ((playerShip.inventory["Rum"] || 0) > 0) {
              playerShip.money += currentCity.goods["Rum"].price;
              playerShip.inventory["Rum"]--;
              currentCity.goods["Rum"].quantity++;
              logMessage("Sold 1 Rum.");
            }
            break;
          case "w":
          case "W": // Sell Spices
            if ((playerShip.inventory["Spices"] || 0) > 0) {
              playerShip.money += currentCity.goods["Spices"].price;
              playerShip.inventory["Spices"]--;
              currentCity.goods["Spices"].quantity++;
              logMessage("Sold 1 Spices.");
            }
            break;
          case "e":
          case "E": // Sell Gold
            if ((playerShip.inventory["Gold"] || 0) > 0) {
              playerShip.money += currentCity.goods["Gold"].price;
              playerShip.inventory["Gold"]--;
              currentCity.goods["Gold"].quantity++;
              logMessage("Sold 1 Gold.");
            }
            break;
          case "4": // Buy Cannon
            if (playerShip.money >= 50) {
              playerShip.money -= 50;
              playerShip.cannons++;
              logMessage("Bought a Cannon.");
            }
            break;
          case "r":
          case "R": // Recruit Crew
            if (playerShip.money >= 10) {
              playerShip.money -= 10;
              playerShip.crew += 5;
              logMessage("Recruited 5 Crew members.");
            }
            break;
          case "v":
          case "V": // Sell Captured Ship
            let capturedIndex = ships.findIndex(s => s.captured);
            if (capturedIndex !== -1) {
              playerShip.money += 100;
              ships.splice(capturedIndex, 1);
              logMessage("Sold captured ship for 100 gold.");
            }
            break;
          case "y":
          case "Y": // Sell Cannon
            if (playerShip.cannons > 0) {
              playerShip.cannons--;
              playerShip.money += 30;
              logMessage("Sold a Cannon for 30 gold.");
            }
            break;
        }
        // Refresh the trade menu display.
        openTradeMenu(currentCity);
      }
    });
    
    /***********************
     * Capturing Enemy Ships
     ***********************/
    function attemptCapture() {
      // Look for an enemy ship within 50px whose HP is below 15.
      for (let ship of ships) {
        if (!ship.isPlayer && !ship.captured && distance(playerShip.x, playerShip.y, ship.x, ship.y) < 50 && ship.health < 15) {
          const choice = confirm("Capture enemy ship: OK to take over, Cancel to sink.");
          if (choice) {
            ship.captured = true;
            ship.nation = playerShip.nation;
            logMessage("Captured enemy ship!");
          } else {
            playerShip.money += 50;
            logMessage("Sunk enemy ship for loot!");
            ships = ships.filter(s => s !== ship);
          }
          break;
        }
      }
    }
    
    /***********************
     * Saving & Loading
     ***********************/
    // Save game state to localStorage.
    function saveGame() {
      const state = {
        islands, cities, ships, cannonballs, playerShip, relationships
      };
      localStorage.setItem("pirateGameSave", JSON.stringify(state));
      logMessage("Game saved.");
    }
    
    // Load game state from localStorage.
    function loadGame() {
      const stateStr = localStorage.getItem("pirateGameSave");
      if (stateStr) {
        const state = JSON.parse(stateStr);
        islands = state.islands;
        cities = state.cities;
        ships = state.ships;
        cannonballs = state.cannonballs;
        playerShip = ships.find(s => s.isPlayer);
        relationships = state.relationships;
        logMessage("Game loaded.");
      } else {
        logMessage("No saved game found.");
      }
    }
    
    /***********************
     * Initialization & Loop Start
     ***********************/
    function initGame() {
      initRelationships();
      generateIslands();
      generateCities();
      generateEnemyShips();
      spawnPlayerShip();
      requestAnimationFrame(gameLoop);
    }
    
    initGame();
  </script>
</body>
</html>
