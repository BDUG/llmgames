<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Pirate Game – Städte, Handel, Kanonen &amp; Kaperungen</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #87ceeb; /* Himmel/Meer */
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      display: block;
      background: #add8e6; /* Wasser */
      border: 2px solid #333;
    }
    /* Der Konsolenbereich unter der Karte */
    #gameConsole {
      width: 800px;
      height: 100px;
      background: #222;
      color: #0f0;
      font-family: monospace;
      font-size: 14px;
      overflow-y: auto;
      padding: 5px;
      box-sizing: border-box;
    }
    /* Neuer Bereich für die Tastatur-Kommandos */
    #keyCommands {
      position: absolute;
      left: 10px;
      top: 10px;
      width: 220px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid #000;
      padding: 10px;
      font-family: sans-serif;
      font-size: 14px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <!-- Liste der möglichen Tastatur-Kommandos -->
  <div id="keyCommands">
    <strong>Tastatur-Kommandos</strong>
    <ul style="padding-left: 20px; margin: 5px 0;">
      <li><strong>Im Menü:</strong></li>
      <li>Enter: Spiel starten</li>
      <li><strong>Im Spiel (nicht im Handel):</strong></li>
      <li>← / →: Schiff drehen</li>
      <li>↑: Vorwärts fahren</li>
      <li>Space: Kanone abfeuern</li>
      <li>P: Pause</li>
      <li>M: Kartenansicht</li>
      <li>S: Spiel speichern</li>
      <li>L: Spiel laden</li>
      <li>T: Handel starten (bei nahegelegener Stadt)</li>
      <li>C: Schiff kapern &amp; plündern</li>
      <li><strong>Im Handel:</strong></li>
      <li>1,2,3: Waren kaufen</li>
      <li>Q, W, E: Waren verkaufen</li>
      <li>4: Kanone kaufen</li>
      <li>R: Crew rekrutieren</li>
      <li>V: Gekaperte Schiffe verkaufen</li>
      <li>Y: Kanone verkaufen</li>
      <li>T: Handel beenden</li>
    </ul>
  </div>
  
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <!-- Konsolenbereich unter der Karte -->
  <div id="gameConsole"></div>
  
  <script>
    // Überschreibe console.log, sodass Nachrichten auch in den onscreen "gameConsole"-Bereich geschrieben werden.
    (function() {
      const originalLog = console.log;
      const gameConsole = document.getElementById("gameConsole");
      console.log = function(...args) {
        originalLog.apply(console, args);
        const message = args.join(" ");
        const line = document.createElement("div");
        line.textContent = message;
        gameConsole.appendChild(line);
        // Scrollt zum Ende
        gameConsole.scrollTop = gameConsole.scrollHeight;
      };
    })();

    // ===== Konstanten und Einstellungen =====
    const CANVAS_WIDTH = 800;
    const CANVAS_HEIGHT = 600;
    const WORLD_WIDTH = 2400;
    const WORLD_HEIGHT = 1600;
    const ISLAND_COUNT = 20;
    const ENEMY_COUNT = 10;
    const PROJECTILE_SPEED = 4;
    const PROJECTILE_DAMAGE = 10;
    const PROJECTILE_SIZE = 3;
    const PROJECTILE_RANGE = 80;
    const TURN_RATE = 0.05;
    const NEAR_THRESHOLD = 50;
    const TRADE_OVERLAY_RECT = { x: 100, y: 100, width: 600, height: 400 };
    const STUCK_THRESHOLD = 120;
    const MIN_MOVEMENT = 2;
    
    // Preis für eine Kanone
    const CANNON_PRICE = 150;
    // Verkaufspreis für eine Kanone
    const CANNON_SELL_PRICE = 75;
    
    // HP-Schwelle, unter der ein Schiff kapert werden kann
    const CAPTURE_HP_THRESHOLD = 15;

    // Verkaufspreise für gekaperte Schiffe (basierend auf Schiffstyp)
    const shipSalePrices = {
      "Sloop": 100,
      "Brig": 200,
      "Galleon": 300
    };

    // ===== Canvas-Setup =====
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // ===== Spielzustände =====
    let gameState = "menu"; // "menu", "playing", "paused", "map"
    let tradeActive = false;

    // ===== Welt- und Kameradaten =====
    const world = { width: WORLD_WIDTH, height: WORLD_HEIGHT };
    const camera = { x: 0, y: 0 };

    // ===== Nationen, Farben und Beziehungen =====
    const nations = ["Holland", "Spanien", "Frankreich", "England"];
    const nationColors = {
      "Holland": "orange",
      "Spanien": "red",
      "Frankreich": "blue",
      "England": "gray"
    };

    let nationRelations = {};
    nations.forEach(n1 => {
      nationRelations[n1] = {};
      nations.forEach(n2 => {
        nationRelations[n1][n2] = (n1 === n2) ? "self" : (Math.random() < 0.5 ? "peace" : "war");
      });
    });
    const areNationsAtWar = (nation1, nation2) =>
      nation1 !== nation2 && nationRelations[nation1][nation2] === "war";

    let lastNationRelationUpdate = 0;
    function updateNationRelations() {
      const n1 = nations[Math.floor(Math.random() * nations.length)];
      let n2;
      do {
        n2 = nations[Math.floor(Math.random() * nations.length)];
      } while (n1 === n2);
      const currentRelation = nationRelations[n1][n2];
      const newRelation = currentRelation === "war" ? "peace" : "war";
      nationRelations[n1][n2] = newRelation;
      nationRelations[n2][n1] = newRelation;
      console.log(`Dynamisches Ereignis: ${n1} und ${n2} sind jetzt ${newRelation}.`);
    }

    // ===== Hilfsfunktionen =====
    const distance = (x1, y1, x2, y2) =>
      Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);

    function adjustAngle(current, desired, turnRate) {
      let diff = desired - current;
      diff = Math.atan2(Math.sin(diff), Math.cos(diff));
      if (diff > turnRate) return current + turnRate;
      if (diff < -turnRate) return current - turnRate;
      return desired;
    }

    // Funktion, um die nächstgelegene Stadt zu finden
    function findNearestCity(x, y) {
      let nearest = null;
      let minDist = Infinity;
      cities.forEach(city => {
        let d = distance(x, y, city.x, city.y);
        if(d < minDist) {
          minDist = d;
          nearest = city;
        }
      });
      return nearest;
    }

    // Reaktivierungs-Funktion: Setzt den Spieler in die Nähe der nächstgelegenen Stadt,
    // weist ihm den Schiffstyp "Sloop" zu, setzt HP auf 100 und gibt 100 Gold.
    function respawnPlayer() {
      let city = findNearestCity(player.x, player.y);
      if (!city) {
        city = cities[0];
      }
      const newPos = getWaterPositionNearCity(city);
      player.x = newPos.x;
      player.y = newPos.y;
      player.shipType = "Sloop";
      player.hp = 100;
      player.money = 100;
      player.currentCrew = 10; // Standardwert für den Sloop
      console.log(`Du bist gestorben! Reaktiviert in ${city.name} mit einem Sloop und 100 Gold.`);
    }

    // ===== Kartengenerierung: Inseln und Städte =====
    let islands = [];
    let cities = [];

    function generateIsland(center, radius, vertexCount) {
      const points = [];
      for (let i = 0; i < vertexCount; i++) {
        const angle = (i / vertexCount) * 2 * Math.PI;
        const randomFactor = 0.7 + Math.random() * 0.6;
        const r = radius * randomFactor;
        points.push({ x: center.x + r * Math.cos(angle), y: center.y + r * Math.sin(angle) });
      }
      return points;
    }

    // Erzeugt eine Stadt auf einem zufälligen Segment der Insel
    function generateCoastalCityForIsland(islandPolygon, cityName) {
      const n = islandPolygon.length;
      const i = Math.floor(Math.random() * n);
      const j = (i + 1) % n;
      const p1 = islandPolygon[i], p2 = islandPolygon[j];
      const t = Math.random();
      return { name: cityName, x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y) };
    }

    function generateMap() {
      islands = [];
      cities = [];
      for (let i = 0; i < ISLAND_COUNT; i++) {
        const radius = 50 + Math.random() * 100;
        const safeMargin = radius + 20;
        const center = {
          x: safeMargin + Math.random() * (world.width - 2 * safeMargin),
          y: safeMargin + Math.random() * (world.height - 2 * safeMargin)
        };
        const vertexCount = 6 + Math.floor(Math.random() * 5);
        const islandPolygon = generateIsland(center, radius, vertexCount);
        islands.push({ name: `Insel ${i + 1}`, points: islandPolygon });
        // Erzeuge 2 Städte pro Insel:
        for (let j = 0; j < 2; j++) {
          let candidateCity;
          let attempts = 0;
          const maxAttempts = 20;
          do {
            candidateCity = generateCoastalCityForIsland(islandPolygon, `Stadt ${i * 2 + j + 1}`);
            attempts++;
          } while (attempts < maxAttempts && cities.some(existingCity => distance(candidateCity.x, candidateCity.y, existingCity.x, existingCity.y) < 100));
          // Zusätzliche Eigenschaften der Stadt:
          candidateCity.nation = nations[Math.floor(Math.random() * nations.length)];
          candidateCity.population = 500 + Math.floor(Math.random() * 1500);
          candidateCity.birthRate = 0.05 + Math.random() * 0.05;
          candidateCity.deathRate = 0.03 + Math.random() * 0.02;
          candidateCity.tradeActivity = 0.5 + Math.random() * 0.5;
          candidateCity.production = 0.5 + Math.random() * 0.5;
          candidateCity.goods = [
            { name: "Rum", price: 10 + Math.floor(Math.random() * 3) },
            { name: "Spices", price: 20 + Math.floor(Math.random() * 3) },
            { name: "Gold", price: 100 + Math.floor(Math.random() * 10) }
          ];
          cities.push(candidateCity);
        }
      }
      ensureEveryNationHasCity();
    }
    function ensureEveryNationHasCity() {
      const present = {};
      cities.forEach(city => { present[city.nation] = true; });
      nations.forEach(nation => {
        if (!present[nation]) {
          const randomCity = cities[Math.floor(Math.random() * cities.length)];
          randomCity.nation = nation;
          console.log(`Nation ${nation} wurde einer Stadt zugewiesen.`);
        }
      });
    }
    generateMap();

    // Neue Hilfsfunktion: Suche eine Stadt für eine bestimmte Nation
    function getCityForNation(nation) {
      const citiesForNation = cities.filter(city => city.nation === nation);
      if (citiesForNation.length > 0) {
        return citiesForNation[Math.floor(Math.random() * citiesForNation.length)];
      }
      return null;
    }

    function pointInPolygon(point, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x, yi = polygon[i].y;
        const xj = polygon[j].x, yj = polygon[j].y;
        const intersect = ((yi > point.y) !== (yj > point.y)) &&
                            (point.x < (xj - xi) * (point.y - yi) / ((yj - yi) || 0.000001) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function isOverLand(point) {
      return islands.some(island => pointInPolygon(point, island.points));
    }
    function isInsideWorld(point) {
      return point.x >= 0 && point.x <= world.width && point.y >= 0 && point.y <= world.height;
    }
    function getRandomWaterPosition() {
      let pos;
      do {
        pos = { x: Math.random() * world.width, y: Math.random() * world.height };
      } while (isOverLand(pos));
      return pos;
    }
    function getWaterPositionNearCity(city) {
      const maxAttempts = 100;
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const angle = Math.random() * 2 * Math.PI;
        const distanceVal = 30 + Math.random() * 40;
        const pos = { x: city.x + distanceVal * Math.cos(angle), y: city.y + distanceVal * Math.sin(angle) };
        if (isInsideWorld(pos) && !isOverLand(pos)) return pos;
      }
      return getRandomWaterPosition();
    }

    // ===== Schiffstypen und Aufgaben =====
    const shipTypes = {
      "Sloop":   { maxCrew: 20, color: "black",   maxCannons: 2 },
      "Brig":    { maxCrew: 40, color: "darkblue", maxCannons: 6 },
      "Galleon": { maxCrew: 80, color: "brown",    maxCannons: 12 }
    };

    const shipTasks = ["Kriegsschiff", "Handelsschiff", "Colonialschiff"];

    // ===== Spieler: Starte in der Nähe einer Stadt der eigenen Nation (England) =====
    const playerCity = getCityForNation("England");
    let playerStartPos;
    if (playerCity) {
      playerStartPos = getWaterPositionNearCity(playerCity);
      console.log(`Spieler startet in der Nähe von ${playerCity.name}.`);
    } else {
      playerStartPos = getRandomWaterPosition();
    }
    let player = {
      x: playerStartPos.x,
      y: playerStartPos.y,
      angle: 0,
      speed: 2,
      size: 20,
      money: 100,
      hp: 100,
      inventory: { "Rum": 0, "Spices": 0, "Gold": 0 },
      nation: "England",
      shipType: "Sloop",
      maxCrew: shipTypes["Sloop"].maxCrew,
      currentCrew: 10,
      cannons: shipTypes["Sloop"].maxCannons  
    };

    // ===== Gegnerische Schiffe =====
    let enemyShips = [];
    for (let i = 0; i < ENEMY_COUNT; i++) {
      const nation = nations[Math.floor(Math.random() * nations.length)];
      const cityForNation = getCityForNation(nation);
      let pos;
      if (cityForNation) {
        pos = getWaterPositionNearCity(cityForNation);
        console.log(`Gegnerisches Schiff (${nation}) startet in der Nähe von ${cityForNation.name}.`);
      } else {
        pos = getRandomWaterPosition();
      }
      const typeKeys = Object.keys(shipTypes);
      const randomType = typeKeys[Math.floor(Math.random() * typeKeys.length)];
      const randomTask = shipTasks[Math.floor(Math.random() * shipTasks.length)];
      enemyShips.push({
        x: pos.x,
        y: pos.y,
        angle: Math.random() * 2 * Math.PI,
        speed: 1,
        size: 15,
        hp: 30,
        alive: true,
        nation: nation,
        shipType: randomType,
        maxCrew: shipTypes[randomType].maxCrew,
        currentCrew: Math.floor(shipTypes[randomType].maxCrew / 2),
        maxCannons: shipTypes[randomType].maxCannons,
        attackCooldown: 2000,
        lastAttack: 0,
        shipTask: randomTask,
        defendTarget: null,
        tradeDestination: null,
        stuckCounter: 0,
        prevX: pos.x,
        prevY: pos.y,
        loot: 50 + Math.floor(Math.random() * 150)
      });
    }
    enemyShips.forEach(ship => {
      const pos = getRandomWaterPosition();
      ship.x = pos.x;
      ship.y = pos.y;
      ship.prevX = pos.x;
      ship.prevY = pos.y;
      ship.stuckCounter = 0;
    });
    
    // Array für gekaperte Schiffe (Flotte des Spielers)
    let capturedShips = [];

    // ===== Projektile =====
    let projectiles = [];

    // ===== Handelsfunktionen =====
    let currentTradeCity = null;
    function buyGood(index) {
      const good = currentTradeCity.goods[index];
      if (player.money >= good.price) {
        player.money -= good.price;
        player.inventory[good.name]++;
        console.log(`Gekauft: ${good.name} zum Preis $${good.price}`);
      } else {
        console.log(`Nicht genug Geld für ${good.name}!`);
      }
    }
    function sellGood(index) {
      const good = currentTradeCity.goods[index];
      if (player.inventory[good.name] > 0) {
        player.money += good.price;
        player.inventory[good.name]--;
        console.log(`Verkauft: ${good.name} zum Preis $${good.price}`);
      } else {
        console.log(`Du besitzt kein ${good.name} zum Verkaufen!`);
      }
    }
    function recruitCrew() {
      const costPerCrew = 5;
      if (player.currentCrew < player.maxCrew) {
        if (currentTradeCity.population > 0 && player.money >= costPerCrew) {
          player.money -= costPerCrew;
          player.currentCrew++;
          currentTradeCity.population--;
          console.log(`Crew rekrutiert. Aktuelle Crew: ${player.currentCrew}`);
        } else {
          console.log("Nicht genug Geld oder keine Bevölkerung verfügbar!");
        }
      } else {
        console.log("Maximale Besatzung erreicht!");
      }
    }
    function buyCannon() {
      if (player.money >= CANNON_PRICE) {
        player.money -= CANNON_PRICE;
        player.cannons++;
        console.log(`Kanone gekauft! Aktuelle Kanonen: ${player.cannons}`);
      } else {
        console.log("Nicht genug Geld für eine Kanone!");
      }
    }
    // Neue Funktion: Verkauft eine Kanone im Handel
    function sellCannon() {
      if (player.cannons > 0) {
        player.cannons--;
        player.money += CANNON_SELL_PRICE;
        console.log(`Kanone verkauft! Du erhältst $${CANNON_SELL_PRICE}.`);
      } else {
        console.log("Du besitzt keine Kanone, die verkauft werden könnte.");
      }
    }
    // Angepasste Funktion: Beim Kapern wird nun gefragt, ob das Schiff übernommen oder versenkt werden soll.
    function captureShip() {
      for (let i = 0; i < enemyShips.length; i++) {
        let ship = enemyShips[i];
        if (ship.nation !== player.nation &&
            distance(player.x, player.y, ship.x, ship.y) < 50 &&
            ship.hp < CAPTURE_HP_THRESHOLD) {
          enemyShips.splice(i, 1);
          
          let übernehmen = confirm(`Möchtest du das Schiff von ${ship.nation} übernehmen? (OK = Übernehmen, Abbrechen = Versenken)`);
          
          if (übernehmen) {
            capturedShips.push(ship);
            ship.shipTask = "Kaper";
            ship.hp = 30;
            console.log(`Schiff von ${ship.nation} erfolgreich gekapert und übernommen!`);
          } else {
            console.log(`Schiff von ${ship.nation} wurde versenkt!`);
          }
          
          let lootAmount = ship.loot || 0;
          if (lootAmount > 0) {
            player.money += lootAmount;
            console.log(`Plünderung erfolgreich: Du erhältst $${lootAmount}.`);
            ship.loot = 0;
          }
          
          return;
        }
      }
      console.log("Kein Schiff in Reichweite oder Schiff nicht schwach genug!");
    }
    // Neue Funktion: Verkauft ein gekapertes Schiff aus der Flotte.
    function sellCapturedShip() {
      if (capturedShips.length > 0) {
        let ship = capturedShips.shift();
        let price = shipSalePrices[ship.shipType] || 50;
        player.money += price;
        console.log(`Gekapertes Schiff vom Typ ${ship.shipType} wurde verkauft! Du erhältst $${price}.`);
      } else {
        console.log("Keine gekaperten Schiffe vorhanden, die verkauft werden könnten.");
      }
    }

    // ===== Tastatursteuerung =====
    let keys = {};
    document.addEventListener("keydown", e => {
      if (gameState === "menu") {
        if (e.key === "Enter") gameState = "playing";
        return;
      }
      if (gameState === "paused" && (e.key === "P" || e.key === "p")) {
        gameState = "playing";
        return;
      }
      if (gameState === "map" && (e.key === "M" || e.key === "m")) {
        gameState = "playing";
        return;
      }
      if (gameState === "playing" && !tradeActive) {
        if (e.key === "s" || e.key === "S") { saveGame(); return; }
        if (e.key === "l" || e.key === "L") { loadGame(); return; }
      }
      if (!tradeActive) {
        if (e.key === "P" || e.key === "p") { gameState = "paused"; return; }
        if (e.key === "M" || e.key === "m") { gameState = "map"; return; }
      }
      if (tradeActive) {
        switch (e.key) {
          case "1": buyGood(0); break;
          case "2": buyGood(1); break;
          case "3": buyGood(2); break;
          case "4": buyCannon(); break;
          case "q": case "Q": sellGood(0); break;
          case "w": case "W": sellGood(1); break;
          case "e": case "E": sellGood(2); break;
          case "r": case "R": recruitCrew(); break;
          case "v": case "V": sellCapturedShip(); break;
          case "y": case "Y": sellCannon(); break;
          case "T": case "t":
            {
              const tradeCity = currentTradeCity;
              tradeActive = false;
              currentTradeCity = null;
              if (tradeCity) {
                const newPos = getWaterPositionNearCity(tradeCity);
                player.x = newPos.x;
                player.y = newPos.y;
                console.log(`Handel beendet. Schiff wurde in das Wasser vor ${tradeCity.name} gesetzt.`);
              }
            }
            break;
          default: break;
        }
        return;
      } else {
        if (e.key === "T" || e.key === "t") {
          const city = nearCity();
          if (city) {
            tradeActive = true;
            currentTradeCity = city;
            console.log(`Handel gestartet in ${city.name}. Drücke 1-3 zum Kaufen, 4 zum Kauf von Kanonen, Q/W/E zum Verkaufen, R zum Rekrutieren, V zum Verkauf von Schiffen, Y zum Verkauf von Kanonen, T zum Beenden.`);
          }
          return;
        }
        if (e.key === "c" || e.key === "C") {
          captureShip();
          return;
        }
        if (e.key === " ") fireProjectile(player, player.angle);
        keys[e.key] = true;
      }
    });
    document.addEventListener("keyup", e => {
      if (gameState === "playing" && !tradeActive) keys[e.key] = false;
    });
    function nearCity() {
      for (const city of cities) {
        if (!isOverLand({ x: city.x, y: city.y })) continue;
        if (distance(player.x, player.y, city.x, city.y) < NEAR_THRESHOLD) return city;
      }
      return null;
    }

    // ===== Zeichenfunktionen =====
    function drawFlag(city, x, y) {
      const flagWidth = 14, flagHeight = 10;
      ctx.fillStyle = nationColors[city.nation] || "gray";
      ctx.fillRect(x, y - flagHeight, flagWidth, flagHeight);
      ctx.fillStyle = "white";
      ctx.font = "8px Arial";
      ctx.textAlign = "center";
      ctx.fillText(city.nation.substring(0, 2).toUpperCase(), x + flagWidth / 2, y - 2);
    }
    function drawTradeOverlay() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(TRADE_OVERLAY_RECT.x, TRADE_OVERLAY_RECT.y, TRADE_OVERLAY_RECT.width, TRADE_OVERLAY_RECT.height);
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.textAlign = "center";
      const title = currentTradeCity ? `HANDELS-BILDSCHIRM - ${currentTradeCity.name}` : "HANDELS-BILDSCHIRM";
      ctx.fillText(title, canvas.width / 2, TRADE_OVERLAY_RECT.y + 40);
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      if (currentTradeCity) {
        ctx.fillText("Drücke 1: Kaufe " + currentTradeCity.goods[0].name +
          " - Preis: $" + Math.round(currentTradeCity.goods[0].price) +
          " (Anzahl: " + player.inventory[currentTradeCity.goods[0].name] + ")", 120, 180);
        ctx.fillText("Drücke 2: Kaufe " + currentTradeCity.goods[1].name +
          " - Preis: $" + Math.round(currentTradeCity.goods[1].price) +
          " (Anzahl: " + player.inventory[currentTradeCity.goods[1].name] + ")", 120, 210);
        ctx.fillText("Drücke 3: Kaufe " + currentTradeCity.goods[2].name +
          " - Preis: $" + Math.round(currentTradeCity.goods[2].price) +
          " (Anzahl: " + player.inventory[currentTradeCity.goods[2].name] + ")", 120, 240);
        ctx.fillText("Drücke Q: Verkaufe " + currentTradeCity.goods[0].name +
          " - Preis: $" + Math.round(currentTradeCity.goods[0].price) +
          " (Anzahl: " + player.inventory[currentTradeCity.goods[0].name] + ")", 400, 180);
        ctx.fillText("Drücke W: Verkaufe " + currentTradeCity.goods[1].name +
          " - Preis: $" + Math.round(currentTradeCity.goods[1].price) +
          " (Anzahl: " + player.inventory[currentTradeCity.goods[1].name] + ")", 400, 210);
        ctx.fillText("Drücke E: Verkaufe " + currentTradeCity.goods[2].name +
          " - Preis: $" + Math.round(currentTradeCity.goods[2].price) +
          " (Anzahl: " + player.inventory[currentTradeCity.goods[2].name] + ")", 400, 240);
      }
      ctx.fillText("Drücke 4: Kaufe Kanone - Preis: $" + CANNON_PRICE, 120, 270);
      ctx.fillText("Drücke Y: Verkaufe eine Kanone - Preis: $" + CANNON_SELL_PRICE, 120, 300);
      ctx.fillText("Drücke R: Rekrutiere Crew (5$ pro Mann)", 120, 330);
      ctx.fillText("Drücke V: Verkaufe ein gekapertes Schiff", 120, 360);
      ctx.fillText("Drücke T, um den Handel zu beenden.", 120, 390);
      ctx.fillText(`Dein Geld: $${player.money}`, 120, 430);
      ctx.fillText(`Inventar: Rum:${player.inventory["Rum"]} Spices:${player.inventory["Spices"]} Gold:${player.inventory["Gold"]}`, 120, 460);
      ctx.fillText(`Crew: ${player.currentCrew}/${player.maxCrew}`, 120, 490);
    }
    function drawMinimap() {
      const minimapWidth = 200, minimapHeight = 200, padding = 10;
      const scaleX = minimapWidth / world.width;
      const scaleY = minimapHeight / world.height;
      const mapX = canvas.width - minimapWidth - padding;
      const mapY = padding;
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
      ctx.fillRect(mapX, mapY, minimapWidth, minimapHeight);
      islands.forEach(island => {
        ctx.fillStyle = "#f4a460";
        ctx.beginPath();
        island.points.forEach((pt, index) => {
          const miniX = mapX + pt.x * scaleX;
          const miniY = mapY + pt.y * scaleY;
          index === 0 ? ctx.moveTo(miniX, miniY) : ctx.lineTo(miniX, miniY);
        });
        ctx.closePath();
        ctx.fill();
      });
      cities.forEach(city => {
        if (isOverLand({ x: city.x, y: city.y })) {
          const miniX = mapX + city.x * scaleX;
          const miniY = mapY + city.y * scaleY;
          ctx.fillStyle = "green";
          ctx.beginPath();
          ctx.arc(miniX, miniY, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      const playerMiniX = mapX + player.x * scaleX;
      const playerMiniY = mapY + player.y * scaleY;
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(playerMiniX, playerMiniY, player.size * scaleX, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.strokeRect(mapX, mapY, minimapWidth, minimapHeight);
    }
    function drawHUD() {
      ctx.fillStyle = "black";
      ctx.font = "16px Arial";
      ctx.textAlign = "left";
      ctx.fillText("HP: " + player.hp, 10, 20);
      ctx.fillText("Money: $" + player.money, 10, 40);
      ctx.fillText("Crew: " + player.currentCrew + "/" + player.maxCrew, 10, 60);
      ctx.fillText("Ship: " + player.shipType, 10, 80);
      ctx.fillText("Nation: " + player.nation, 10, 100);
      ctx.fillText("Kanonen: " + player.cannons, 10, 120);
    }
    function renderMenu() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      ctx.font = "40px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Sid Meier's Pirates Clone", canvas.width / 2, canvas.height / 2 - 40);
      ctx.font = "20px Arial";
      ctx.fillText("Drücke Enter zum Starten", canvas.width / 2, canvas.height / 2);
      ctx.fillText("Drücke S zum Speichern und L zum Laden", canvas.width / 2, canvas.height / 2 + 40);
    }
    function renderPauseOverlay() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "white";
      ctx.font = "30px Arial";
      ctx.textAlign = "center";
      ctx.fillText("PAUSE", canvas.width / 2, canvas.height / 2);
      ctx.font = "20px Arial";
      ctx.fillText("Drücke P zum Fortsetzen", canvas.width / 2, canvas.height / 2 + 40);
    }
    function renderMapOverlay() {
      ctx.fillStyle = "#87ceeb";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      const scale = Math.min(canvas.width / world.width, canvas.height / world.height);
      const offsetX = (canvas.width - world.width * scale) / 2;
      const offsetY = (canvas.height - world.height * scale) / 2;
      islands.forEach(island => {
        ctx.fillStyle = "#f4a460";
        ctx.beginPath();
        island.points.forEach((pt, index) => {
          const x = offsetX + pt.x * scale;
          const y = offsetY + pt.y * scale;
          index === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        });
        ctx.closePath();
        ctx.fill();
      });
      cities.forEach(city => {
        if (isOverLand({ x: city.x, y: city.y })) {
          const x = offsetX + city.x * scale;
          const y = offsetY + city.y * scale;
          ctx.fillStyle = "green";
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "black";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          ctx.fillText(city.name, x, y - 8);
        }
      });
      const playerX = offsetX + player.x * scale;
      const playerY = offsetY + player.y * scale;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(playerX, playerY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(0, 0, canvas.width, canvas.height < 40 ? canvas.height : 40);
      ctx.fillStyle = "white";
      ctx.font = "20px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Karte der Karibik", canvas.width / 2, 28);
      ctx.font = "16px Arial";
      ctx.fillText("Drücke M zum Beenden der Kartenansicht", canvas.width / 2, canvas.height - 20);
    }
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawWorld();
      drawShip(player, shipTypes[player.shipType].color);
      enemyShips.forEach(ship => { if (ship.alive) drawShip(ship, shipTypes[ship.shipType].color); });
      capturedShips.forEach(ship => { drawShip(ship, shipTypes[ship.shipType].color); });
      projectiles.forEach(drawProjectile);
      if (tradeActive) drawTradeOverlay();
      drawMinimap();
    }
    function drawWorld() {
      ctx.fillStyle = "#add8e6";
      ctx.fillRect(-camera.x, -camera.y, world.width, world.height);
      islands.forEach(island => {
        ctx.fillStyle = "#f4a460";
        ctx.beginPath();
        island.points.forEach(pt => {
          const screenX = pt.x - camera.x;
          const screenY = pt.y - camera.y;
          ctx.lineTo(screenX, screenY);
        });
        ctx.closePath();
        ctx.fill();
      });
      cities.forEach(city => {
        if (isOverLand({ x: city.x, y: city.y })) {
          drawHouse(city);
        }
      });
    }
    function drawHouse(city) {
      const screenX = city.x - camera.x;
      const screenY = city.y - camera.y;
      ctx.fillStyle = "saddlebrown";
      ctx.fillRect(screenX - 6, screenY - 12, 12, 12);
      ctx.fillStyle = "firebrick";
      ctx.beginPath();
      ctx.moveTo(screenX - 8, screenY - 12);
      ctx.lineTo(screenX, screenY - 20);
      ctx.lineTo(screenX + 8, screenY - 12);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "black";
      ctx.font = "10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(city.name, screenX, screenY - 22);
      drawFlag(city, screenX + 10, screenY - 12);
    }
    function drawShip(ship, color) {
      const screenX = ship.x - camera.x;
      const screenY = ship.y - camera.y;
      ctx.save();
      ctx.translate(screenX, screenY);
      ctx.rotate(ship.angle);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(ship.size, 0);
      ctx.lineTo(-ship.size / 2, ship.size / 2);
      ctx.lineTo(-ship.size / 2, -ship.size / 2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "white";
      ctx.font = "12px Arial";
      ctx.textAlign = "center";
      ctx.fillText(ship.hp, 0, -ship.size - 10);
      if (ship === player) {
        ctx.fillText(`Crew: ${player.currentCrew}/${player.maxCrew}`, 0, ship.size + 15);
      }
      ctx.restore();
    }
    function drawProjectile(proj) {
      const screenX = proj.x - camera.x;
      const screenY = proj.y - camera.y;
      ctx.save();
      ctx.translate(screenX, screenY);
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(0, 0, PROJECTILE_SIZE, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    function fireProjectile(shooter, angle) {
      projectiles.push({
        x: shooter.x + Math.cos(angle) * shooter.size,
        y: shooter.y + Math.sin(angle) * shooter.size,
        initialX: shooter.x + Math.cos(angle) * shooter.size,
        initialY: shooter.y + Math.sin(angle) * shooter.size,
        angle: angle,
        speed: PROJECTILE_SPEED,
        damage: PROJECTILE_DAMAGE,
        owner: shooter
      });
    }
    function update(timestamp) {
      if (timestamp - lastNationRelationUpdate > 20000) {
        updateNationRelations();
        lastNationRelationUpdate = timestamp;
      }
      if (!tradeActive) {
        let newX = player.x, newY = player.y;
        if (keys["ArrowLeft"]) player.angle -= TURN_RATE;
        if (keys["ArrowRight"]) player.angle += TURN_RATE;
        if (keys["ArrowUp"]) {
          newX += Math.cos(player.angle) * player.speed;
          newY += Math.sin(player.angle) * player.speed;
        }
        if (isInsideWorld({ x: newX, y: newY }) && !isOverLand({ x: newX, y: newY })) {
          player.x = newX;
          player.y = newY;
        }
      }
      updateEnemyShips(timestamp);
      updateProjectiles();
      capturedShips.forEach(ship => {
        const dx = player.x - ship.x;
        const dy = player.y - ship.y;
        const angle = Math.atan2(dy, dx);
        ship.angle = angle;
        ship.x += Math.cos(angle) * ship.speed;
        ship.y += Math.sin(angle) * ship.speed;
      });
      cities.forEach(city => {
        const dt = 1 / 60;
        const computedDeathRate = city.deathRate * (1 + (1 - city.tradeActivity) + (1 - city.production));
        city.population += city.population * city.birthRate * dt - city.population * computedDeathRate * dt;
        if (city.population > 2000) {
          city.population = 2000;
        }
        if (city.population < 0) {
          city.population = 0;
        }
        city.population = Math.round(city.population);
        city.goods.forEach(good => {
          const change = (Math.random() - 0.5) * 0.2;
          good.price = Math.max(1, Math.round(good.price + change));
        });
      });
      camera.x = player.x - CANVAS_WIDTH / 2;
      camera.y = player.y - CANVAS_HEIGHT / 2;

      // Reaktivierung, wenn HP <= 0.
      if (player.hp <= 0) {
        respawnPlayer();
      }
    }
    function updateProjectiles() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        proj.x += Math.cos(proj.angle) * proj.speed;
        proj.y += Math.sin(proj.angle) * proj.speed;
        const dx = proj.x - proj.initialX;
        const dy = proj.y - proj.initialY;
        if (Math.sqrt(dx * dx + dy * dy) > PROJECTILE_RANGE ||
            proj.x < 0 || proj.x > world.width || proj.y < 0 || proj.y > world.height) {
          projectiles.splice(i, 1);
          continue;
        }
        // Spieler wird im Handelsmodus nicht getroffen.
        if (proj.owner !== player && player.hp > 0 && distance(proj.x, proj.y, player.x, player.y) < player.size) {
          if (!tradeActive) {
            player.hp -= proj.damage;
            console.log("Spieler getroffen! HP: " + player.hp);
          }
          projectiles.splice(i, 1);
          continue;
        }
        for (let j = 0; j < enemyShips.length; j++) {
          const ship = enemyShips[j];
          if (!ship.alive) continue;
          if (proj.owner !== ship && distance(proj.x, proj.y, ship.x, ship.y) < ship.size) {
            ship.hp -= proj.damage;
            console.log(`Schiff (${ship.shipTask}, ${ship.nation}) getroffen! HP: ${ship.hp}`);
            projectiles.splice(i, 1);
            if (ship.hp <= 0) {
              ship.alive = false;
              console.log(`Schiff (${ship.shipTask}, ${ship.nation}) versenkt!`);
            } else if (ship.shipTask !== "Kriegsschiff") {
              ship.defendTarget = proj.owner;
            }
            break;
          }
        }
      }
    }
    function updateEnemyShips(timestamp) {
      enemyShips.forEach(ship => {
        if (!ship.alive) return;
        // Im Handelsmodus greifen Kriegsschiffe nicht an.
        if (tradeActive && ship.shipTask === "Kriegsschiff") return;
        if (tradeActive && ship.shipTask !== "Kriegsschiff") {
          ship.defendTarget = player;
        }
        switch (ship.shipTask) {
          case "Kriegsschiff":
            if (areNationsAtWar(ship.nation, player.nation)) {
              const dx = player.x - ship.x;
              const dy = player.y - ship.y;
              const desiredAngle = Math.atan2(dy, dx);
              ship.angle = adjustAngle(ship.angle, desiredAngle, TURN_RATE);
              if (!tradeActive && distance(player.x, player.y, ship.x, ship.y) < 100 &&
                  timestamp - ship.lastAttack > ship.attackCooldown) {
                fireProjectile(ship, ship.angle);
                ship.lastAttack = timestamp;
              }
            } else {
              ship.angle += (Math.random() - 0.5) * 0.02;
            }
            break;
          case "Handelsschiff":
            if (ship.defendTarget && ship.defendTarget.alive) {
              const dx = ship.defendTarget.x - ship.x;
              const dy = ship.defendTarget.y - ship.y;
              ship.angle = adjustAngle(ship.angle, Math.atan2(dy, dx), TURN_RATE);
              if (distance(ship.x, ship.y, ship.defendTarget.x, ship.defendTarget.y) < 100 &&
                  timestamp - ship.lastAttack > ship.attackCooldown) {
                fireProjectile(ship, ship.angle);
                ship.lastAttack = timestamp;
              }
            } else {
              if (!ship.tradeDestination) {
                const friendlyCities = cities.filter(city => city.nation === ship.nation);
                if (friendlyCities.length > 0) {
                  ship.tradeDestination = friendlyCities[Math.floor(Math.random() * friendlyCities.length)];
                }
              } else {
                const dx = ship.tradeDestination.x - ship.x;
                const dy = ship.tradeDestination.y - ship.y;
                ship.angle = adjustAngle(ship.angle, Math.atan2(dy, dx), TURN_RATE);
                if (distance(ship.x, ship.y, ship.tradeDestination.x, ship.tradeDestination.y) < 20) {
                  ship.tradeDestination = null;
                }
              }
            }
            break;
          case "Colonialschiff":
            if (ship.defendTarget && ship.defendTarget.alive) {
              const dx = ship.defendTarget.x - ship.x;
              const dy = ship.defendTarget.y - ship.y;
              ship.angle = adjustAngle(ship.angle, Math.atan2(dy, dx), TURN_RATE);
              if (distance(ship.x, ship.y, ship.defendTarget.x, ship.defendTarget.y) < 100 &&
                  timestamp - ship.lastAttack > ship.attackCooldown) {
                fireProjectile(ship, ship.angle);
                ship.lastAttack = timestamp;
              }
            } else {
              ship.angle += (Math.random() - 0.5) * 0.01;
            }
            break;
        }
        const newX = ship.x + Math.cos(ship.angle) * ship.speed;
        const newY = ship.y + Math.sin(ship.angle) * ship.speed;
        if (!isInsideWorld({ x: newX, y: newY }) || isOverLand({ x: newX, y: newY })) {
          ship.angle += Math.PI / 4;
        } else {
          ship.x = newX;
          ship.y = newY;
        }
        const disp = distance(ship.x, ship.y, ship.prevX, ship.prevY);
        if (disp < MIN_MOVEMENT) {
          ship.stuckCounter++;
        } else {
          ship.stuckCounter = 0;
          ship.prevX = ship.x;
          ship.prevY = ship.y;
        }
        if (ship.stuckCounter > STUCK_THRESHOLD) {
          const newPos = getRandomWaterPosition();
          ship.x = newPos.x;
          ship.y = newPos.y;
          ship.prevX = newPos.x;
          ship.prevY = newPos.y;
          ship.stuckCounter = 0;
          console.log(`Schiff (${ship.shipTask}, ${ship.nation}) war festsitzend – neu positioniert.`);
        }
      });
    }

    // ===== Hauptspielschleife =====
    function gameLoop(timestamp) {
      if (gameState === "menu") {
        renderMenu();
      } else if (gameState === "playing") {
        update(timestamp);
        render();
        drawHUD();
      } else if (gameState === "paused") {
        render();
        drawHUD();
        renderPauseOverlay();
      } else if (gameState === "map") {
        renderMapOverlay();
      }
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    // Funktionen zum Speichern und Laden im localStorage
    function saveGame() {
      const saveName = prompt("Bitte gib einen Namen für den Spielstand ein:");
      if (!saveName) {
        console.log("Speichern abgebrochen.");
        return;
      }
      const gameStateToSave = {
        player: player,
        enemyShips: enemyShips,
        capturedShips: capturedShips,
        islands: islands,
        cities: cities
      };
      localStorage.setItem("pirateGameSave_" + saveName, JSON.stringify(gameStateToSave));
      console.log("Spiel gespeichert als: " + saveName);
    }
    function loadGame() {
      let saves = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key.indexOf("pirateGameSave_") === 0) {
          saves.push(key.replace("pirateGameSave_", ""));
        }
      }
      if (saves.length === 0) {
        console.log("Keine gespeicherten Spielstände gefunden!");
        return;
      }
      let selectionText = "Verfügbare Spielstände:\n";
      saves.forEach((saveName, index) => {
        selectionText += (index + 1) + ": " + saveName + "\n";
      });
      selectionText += "\nBitte gib die Nummer des gewünschten Spielstands ein:";
      const selected = prompt(selectionText);
      if (selected === null) {
        console.log("Laden abgebrochen.");
        return;
      }
      const index = parseInt(selected) - 1;
      if (isNaN(index) || index < 0 || index >= saves.length) {
        console.log("Ungültige Auswahl!");
        return;
      }
      const saveName = saves[index];
      const savedData = localStorage.getItem("pirateGameSave_" + saveName);
      if (!savedData) {
        console.log("Kein Spielstand mit diesem Namen gefunden!");
        return;
      }
      try {
        const gameStateLoaded = JSON.parse(savedData);
        player = gameStateLoaded.player;
        enemyShips = gameStateLoaded.enemyShips;
        capturedShips = gameStateLoaded.capturedShips;
        islands = gameStateLoaded.islands;
        cities = gameStateLoaded.cities;
        console.log("Spielstand '" + saveName + "' geladen.");
      } catch(e) {
        console.log("Fehler beim Laden des Spielstands:", e);
      }
    }
  </script>
</body>
</html>
